{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"YOLO-Based Binary Object Sorting System","text":"<p>Welcome! This GitHub page will contain documentation regarding what this project is about as well as progress for where I am at and all developments that have occured. This will serve as a log of my progress.</p> <p>Check out my engineering portfolio to see other projects!</p>"},{"location":"#about-me","title":"About Me","text":"<p>My name is Sidh Gurnani, and I studied Mechanical Engineering at Purdue University, and graduated with my Bachelor's in May 2025. I have been working on this project since June 2024.</p>"},{"location":"#project-milestones-progress","title":"Project Milestones + Progress","text":"<p>Here is a look at where I am at now: </p> Refresh Programming Knowledge Understand Basics of Machine Learning Develop Basic Software 3D Model and Design Physical Product Integrate Software and Hardware Final Testing Reflection and Next Steps"},{"location":"WebUSB_Findings/","title":"Version 0 - WebUSB Findings (Abandoned)","text":""},{"location":"WebUSB_Findings/#brief-intro","title":"Brief Intro","text":"<p>This page outlines the basics of WebUSB, and how I set it up and tested for basic functionality. It also outlines my conclusion, which was presented on the Architecture page.</p> <p>WebUSB is an API that allows certain compatible microcontrollers to be able to communicate to a web browser. This would open up the potential for users to be able to interact with the Arduino using an HTML file. </p> <p>This relates to the project, as it is possible to be able to have a videofeed and have the user see what is going on and allow for a bit of manual control.</p> <p>This guide has some demos as well as code that can be ran to ensure that WebUSB is working as expected. The following is an adapted version of the tutorials presented in this video. For more information about the code and details about WebUSB, watch the linked video. </p>"},{"location":"WebUSB_Findings/#demos","title":"Demos","text":"<ol> <li>USB Recognition</li> <li>Microcontroller to Web Browser Communication</li> <li>Web Browser to Microcontroller Communication</li> </ol>"},{"location":"WebUSB_Findings/#usb-recognition","title":"USB Recognition","text":"<p>The goal of this demo is to create a basic website that will allow the user to plug in a USB device and obtain important details to the console. This demo does not require the use of the WebUSB library, and no code needs to be uploaded to the microcontroller. This means that ANY device, regardless of whether it supports WebUSB or not, can run this test successfully, as this relies on the browser picking up the fact that a USB was plugged in rather than communicating with it.</p> USB_recog.html<pre><code>&lt;a href=\"#\" id=\"click\"&gt;Connect to USB Device&lt;/a&gt;\n\n&lt;script&gt;\nclick.onclick = function() {\n    navigator.usb.requestDevice( {filters: [\n        {'vendorId': 0x2341}\n    ]})\n    .then(device =&gt; {\n        console.log(device)\n        console.log(\"Product Name: \" + device.productName.toString(16))\n        console.log(\"Product ID: \" + device.productId.toString(16))\n        console.log(\"Vendor ID: \"+ device.vendorId.toString(16))\n    })\n    .catch(error =&gt; {\n        console.log(error)\n    })\n}\n&lt;/script&gt;\n</code></pre> <p>Images below show output of html code and how it works when an Arduino Leonardo is connected:</p> <p></p> <p></p> <p>Note that no code is needed for the Arduino.</p>"},{"location":"WebUSB_Findings/#microcontroller-to-web-browser-communication","title":"Microcontroller to Web Browser Communication","text":"<p>The goal of this demo is to be able to send data from the microcontroller and the website. While this demo will work in this particular way, it sets up the backbone for establishing a 2 way communication between the microcontroller and the website.</p> <p>HTML Code:</p> Leo_to_Web.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;USB Communication Test&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=\"#\" id=\"click\"&gt;Listen to Leo&lt;/a&gt;\n        &lt;button id=\"connect\"&gt;Connect&lt;/button&gt;\n\n        &lt;script src=\"serial.js\"&gt;&lt;/script&gt;\n\n        &lt;script&gt;\n            document.getElementById('click').onclick = function() {\n                navigator.usb.requestDevice({ filters: [{ 'vendorId': 0x2341 }] })\n                    .then(device =&gt; {\n                        console.log(device);\n                        console.log(\"Product Name: \" + device.productName);\n                        console.log(\"Product ID: \" + device.productId.toString(16));\n                        console.log(\"Vendor ID: \" + device.vendorId.toString(16));\n                        console.log(\"Device Found! Awaiting messages...\");\n                    })\n                    .catch(error =&gt; {\n                        console.log(error);\n                    });\n            };\n\n            var port;\n            var connectButton = document.getElementById('connect');\n            var textDecoder = new TextDecoder();\n            var textEncoder = new TextEncoder();\n\n            connectButton.addEventListener('click', function() {\n              if (port) {\n                    // If port is already connected, disconnect it\n                    connectButton.textContent = 'Connect';\n                    port.disconnect();\n                    port = null;\n                    console.log('Device is disconnected.');\n                } else {\n                    // If there is no port, then connect to a new port\n                    serial.requestPort().then(selectedPort =&gt; {\n                        port = selectedPort;\n                        port.connect().then(() =&gt; {\n                            console.log('Device is connected to Product ID: ' + port.device_.productId.toString(16) + ' and Vendor ID: ' + port.device_.vendorId.toString(16));\n\n                            connectButton.textContent = 'Disconnect';\n                            port.onReceive = data =&gt; {\n                                console.log(textDecoder.decode(data));\n                            };\n                            port.onReceiveError = error =&gt; {\n                                console.log('Receive error: ' + error);\n                            };\n                        }, error =&gt; {\n                            console.log('Connection error: ' + error);\n                        });\n                    }).catch(error =&gt; {\n                        console.log('Connection error: ' + error);\n                    });\n                }\n            });\n\n            serial.requestPort = function() {\n                const filters = [\n                    { 'vendorId': 0x2341 }\n                ];\n                return navigator.usb.requestDevice({ 'filters': filters }).then(\n                    device =&gt; new serial.Port(device)\n                );\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Arduino Code:</p> Leo2.ino<pre><code>#include &lt;WebUSB.h&gt;\n\n// Modified from example https://webusb.github.io/arduino/demos/console\nWebUSB WebUSBSerial(1, \"webusb.github.io/arduino/demos/console\");\nint c = 0;\n\nvoid setup() {\n  WebUSBSerial.begin(9600);\n  while (!WebUSBSerial) {}\n  delay(100);\n}\n\nvoid loop() {\n  c = c + 1;\n  if (WebUSBSerial){\n    WebUSBSerial.println(c);\n    WebUSBSerial.flush();    \n  } else {\n    c = 0;\n  }\n\n  delay(1000);\n}\n</code></pre> <p>Serial.js code:</p> serial.js<pre><code>var serial = {};\n\n(function() {\n  'use strict';\n\n  serial.getPorts = function() {\n    return navigator.usb.getDevices().then(devices =&gt; {\n      return devices.map(device =&gt; new serial.Port(device));\n    });\n  };\n\n  serial.requestPort = function() {\n    const filters = [\n      { 'vendorId': 0x2341, 'productId': 0x8036 }, // Arduino Leonardo\n      { 'vendorId': 0x2341, 'productId': 0x8037 }, // Arduino Micro\n      { 'vendorId': 0x2341, 'productId': 0x804d }, // Arduino/Genuino Zero\n      { 'vendorId': 0x2341, 'productId': 0x804e }, // Arduino/Genuino MKR1000\n      { 'vendorId': 0x2341, 'productId': 0x804f }, // Arduino MKRZERO\n      { 'vendorId': 0x2341, 'productId': 0x8050 }, // Arduino MKR FOX 1200\n      { 'vendorId': 0x2341, 'productId': 0x8052 }, // Arduino MKR GSM 1400\n      { 'vendorId': 0x2341, 'productId': 0x8053 }, // Arduino MKR WAN 1300\n      { 'vendorId': 0x2341, 'productId': 0x8054 }, // Arduino MKR WiFi 1010\n      { 'vendorId': 0x2341, 'productId': 0x8055 }, // Arduino MKR NB 1500\n      { 'vendorId': 0x2341, 'productId': 0x8056 }, // Arduino MKR Vidor 4000\n      { 'vendorId': 0x2341, 'productId': 0x8057 }, // Arduino NANO 33 IoT\n      { 'vendorId': 0x239A }, // Adafruit Boards!\n    ];\n    return navigator.usb.requestDevice({ 'filters': filters }).then(\n      device =&gt; new serial.Port(device)\n    );\n  }\n\n  serial.Port = function(device) {\n    this.device_ = device;\n    this.interfaceNumber_ = 2;  // original interface number of WebUSB Arduino demo\n    this.endpointIn_ = 5;       // original in endpoint ID of WebUSB Arduino demo\n    this.endpointOut_ = 4;      // original out endpoint ID of WebUSB Arduino demo\n  };\n\n  serial.Port.prototype.connect = function() {\n    let readLoop = () =&gt; {\n      this.device_.transferIn(this.endpointIn_, 64).then(result =&gt; {\n        this.onReceive(result.data);\n        readLoop();\n      }, error =&gt; {\n        this.onReceiveError(error);\n      });\n    };\n\n    return this.device_.open()\n        .then(() =&gt; {\n          if (this.device_.configuration === null) {\n            return this.device_.selectConfiguration(1);\n          }\n        })\n        .then(() =&gt; {\n          var configurationInterfaces = this.device_.configuration.interfaces;\n          configurationInterfaces.forEach(element =&gt; {\n            element.alternates.forEach(elementalt =&gt; {\n              if (elementalt.interfaceClass==0xff) {\n                this.interfaceNumber_ = element.interfaceNumber;\n                elementalt.endpoints.forEach(elementendpoint =&gt; {\n                  if (elementendpoint.direction == \"out\") {\n                    this.endpointOut_ = elementendpoint.endpointNumber;\n                  }\n                  if (elementendpoint.direction==\"in\") {\n                    this.endpointIn_ =elementendpoint.endpointNumber;\n                  }\n                })\n              }\n            })\n          })\n        })\n        .then(() =&gt; this.device_.claimInterface(this.interfaceNumber_))\n        .then(() =&gt; this.device_.selectAlternateInterface(this.interfaceNumber_, 0))\n        // The vendor-specific interface provided by a device using this\n        // Arduino library is a copy of the normal Arduino USB CDC-ACM\n        // interface implementation and so reuses some requests defined by\n        // that specification. This request sets the DTR (data terminal\n        // ready) signal high to indicate to the device that the host is\n        // ready to send and receive data.\n        .then(() =&gt; this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x01,\n            'index': this.interfaceNumber_}))\n        .then(() =&gt; {\n          readLoop();\n        });\n  };\n\n  serial.Port.prototype.disconnect = function() {\n    // This request sets the DTR (data terminal ready) signal low to\n    // indicate to the device that the host has disconnected.\n    return this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x00,\n            'index': this.interfaceNumber_})\n        .then(() =&gt; this.device_.close());\n  };\n\n  serial.Port.prototype.send = function(data) {\n    return this.device_.transferOut(this.endpointOut_, data);\n  };\n})();\n</code></pre> <p>Images below show output and how it works when an Arduino Leonardo is connected:</p> <p></p> <p></p>"},{"location":"WebUSB_Findings/#web-browser-to-microcontroller-communication-blinky","title":"Web Browser to Microcontroller Communication \u2192 Blinky","text":"<p>The goal of this demo is to be able to control a microcontroller by having the user interface with a website. For the project, it would open up many possibilities for human interaction as the sorter is working through sorting. As of today, the only thing that makes sense would be to have a manual override in case something goes wrong, and maybe a stop and start function. An HTML would also be able to display possible metrics that are coming in from the microcontroller. This would include how many items were sorted, a running count of each type of item sorted, etc. Metrics are something that I would consider desirable and not required. The biggest use case of the website would be to train the ML model that would be used to then sort. This would be something very similar to what is implemented on Teachable Machine by Google. </p> <p>This demo uses an Arduino Leonardo and an HTML file to turn on and off the builtin LED. </p> <p>HTML Code:</p> Leo_to_Web_BLINKY.html<pre><code>&lt;a href=\"#\" id=\"connect\"&gt;Connect&lt;/a&gt;\n\n&lt;p&gt;\n    &lt;button id=\"on\"&gt;LED ON&lt;/button&gt;\n    &lt;button id=\"off\"&gt;LED OFF&lt;/button&gt;\n&lt;/p&gt;\n\n&lt;script src=\"serial.js\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\n    serial.requestPort = function() {\n        const filters = [\n            {'vendorId': 0x2341}\n        ];\n        return navigator.usb.requestDevice({'filters': filters}).then(\n            device =&gt; new serial.Port(device)\n        );\n    }\n\n    var port;\n    var connectButton = document.getElementById('connect');\n    var textDecoder = new TextDecoder();\n    var textEncoder = new TextEncoder();\n\n    document.querySelector('#on').addEventListener('click', function() {\n        if (port !== undefined) {\n            port.send(textEncoder.encode('H')).catch(error =&gt; {\n                console.log(\"Error: \" + error)\n            })\n            console.log(\"HTML: Turning on the LED!\")\n        }\n    })\n\n    document.querySelector('#off').addEventListener('click', function() {\n        if (port !== undefined) {\n            port.send(textEncoder.encode('L')).catch(error =&gt; {\n                console.log(\"Error: \" + error)\n            })\n            console.log(\"HTML: Turning off the LED!\")\n        }\n    })\n\n\n    connectButton.addEventListener('click', function() {\n              if (port) {\n                    // If port is already connected, disconnect it\n                    connectButton.textContent = 'Connect';\n                    port.disconnect();\n                    port = null;\n                    console.log('Device is disconnected.');\n                } else {\n                    // If there is no port, then connect to a new port\n                    serial.requestPort().then(selectedPort =&gt; {\n                        port = selectedPort;\n                        port.connect().then(() =&gt; {\n                            console.log('Device is connected to Product ID: ' + port.device_.productId.toString(16) + ' and Vendor ID: ' + port.device_.vendorId.toString(16));\n\n                            connectButton.textContent = 'Disconnect';\n                            port.onReceive = data =&gt; {\n                                console.log(textDecoder.decode(data));\n                            };\n                            port.onReceiveError = error =&gt; {\n                                console.log('Receive error: ' + error);\n                            };\n                        }, error =&gt; {\n                            console.log('Connection error: ' + error);\n                        });\n                    }).catch(error =&gt; {\n                        console.log('Connection error: ' + error);\n                    });\n                }\n            });\n&lt;/script&gt;\n</code></pre> <p>Arduino Code:</p> Blinky.ino<pre><code>#include &lt;WebUSB.h&gt;\nWebUSB WebUSBSerial(1, \"webusb.github.io/arduino/demos/console\");\n\nconst int ledPin = 13;\n\nvoid setup() {\n  WebUSBSerial.begin(9600);\n  while (!WebUSBSerial) {}\n  delay(100);\n\n  SerialUSB.begin(9600);\n  delay(100);\n\n  WebUSBSerial.write(\"Starting blinky!\");\n  WebUSBSerial.flush();\n  SerialUSB.println(\"Starting...\");\n\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  if (WebUSBSerial &amp;&amp; WebUSBSerial.available()) {\n    char byte = WebUSBSerial.read();  // Read the incoming byte as a character\n    WebUSBSerial.write(byte);  // Echo the received byte\n\n    if (byte == 'H') {  // Compare the byte with the character 'H'\n      SerialUSB.println(\"Received H!\");\n      WebUSBSerial.write(\"\\nTurning on LED\");\n      digitalWrite(ledPin, HIGH);  // Turn the LED on\n    } else if (byte == 'L') {  // Compare the byte with the character 'L'\n      SerialUSB.println(\"Received L!\");\n      WebUSBSerial.write(\"\\nTurning off LED\");\n      digitalWrite(ledPin, LOW);  // Turn the LED off\n    }\n\n    WebUSBSerial.flush();\n  }\n}\n</code></pre> <p>Serial.js code (same as before, provided for reference):</p> serial.js<pre><code>var serial = {};\n\n(function() {\n  'use strict';\n\n  serial.getPorts = function() {\n    return navigator.usb.getDevices().then(devices =&gt; {\n      return devices.map(device =&gt; new serial.Port(device));\n    });\n  };\n\n  serial.requestPort = function() {\n    const filters = [\n      { 'vendorId': 0x2341, 'productId': 0x8036 }, // Arduino Leonardo\n      { 'vendorId': 0x2341, 'productId': 0x8037 }, // Arduino Micro\n      { 'vendorId': 0x2341, 'productId': 0x804d }, // Arduino/Genuino Zero\n      { 'vendorId': 0x2341, 'productId': 0x804e }, // Arduino/Genuino MKR1000\n      { 'vendorId': 0x2341, 'productId': 0x804f }, // Arduino MKRZERO\n      { 'vendorId': 0x2341, 'productId': 0x8050 }, // Arduino MKR FOX 1200\n      { 'vendorId': 0x2341, 'productId': 0x8052 }, // Arduino MKR GSM 1400\n      { 'vendorId': 0x2341, 'productId': 0x8053 }, // Arduino MKR WAN 1300\n      { 'vendorId': 0x2341, 'productId': 0x8054 }, // Arduino MKR WiFi 1010\n      { 'vendorId': 0x2341, 'productId': 0x8055 }, // Arduino MKR NB 1500\n      { 'vendorId': 0x2341, 'productId': 0x8056 }, // Arduino MKR Vidor 4000\n      { 'vendorId': 0x2341, 'productId': 0x8057 }, // Arduino NANO 33 IoT\n      { 'vendorId': 0x239A }, // Adafruit Boards!\n    ];\n    return navigator.usb.requestDevice({ 'filters': filters }).then(\n      device =&gt; new serial.Port(device)\n    );\n  }\n\n  serial.Port = function(device) {\n    this.device_ = device;\n    this.interfaceNumber_ = 2;  // original interface number of WebUSB Arduino demo\n    this.endpointIn_ = 5;       // original in endpoint ID of WebUSB Arduino demo\n    this.endpointOut_ = 4;      // original out endpoint ID of WebUSB Arduino demo\n  };\n\n  serial.Port.prototype.connect = function() {\n    let readLoop = () =&gt; {\n      this.device_.transferIn(this.endpointIn_, 64).then(result =&gt; {\n        this.onReceive(result.data);\n        readLoop();\n      }, error =&gt; {\n        this.onReceiveError(error);\n      });\n    };\n\n    return this.device_.open()\n        .then(() =&gt; {\n          if (this.device_.configuration === null) {\n            return this.device_.selectConfiguration(1);\n          }\n        })\n        .then(() =&gt; {\n          var configurationInterfaces = this.device_.configuration.interfaces;\n          configurationInterfaces.forEach(element =&gt; {\n            element.alternates.forEach(elementalt =&gt; {\n              if (elementalt.interfaceClass==0xff) {\n                this.interfaceNumber_ = element.interfaceNumber;\n                elementalt.endpoints.forEach(elementendpoint =&gt; {\n                  if (elementendpoint.direction == \"out\") {\n                    this.endpointOut_ = elementendpoint.endpointNumber;\n                  }\n                  if (elementendpoint.direction==\"in\") {\n                    this.endpointIn_ =elementendpoint.endpointNumber;\n                  }\n                })\n              }\n            })\n          })\n        })\n        .then(() =&gt; this.device_.claimInterface(this.interfaceNumber_))\n        .then(() =&gt; this.device_.selectAlternateInterface(this.interfaceNumber_, 0))\n        // The vendor-specific interface provided by a device using this\n        // Arduino library is a copy of the normal Arduino USB CDC-ACM\n        // interface implementation and so reuses some requests defined by\n        // that specification. This request sets the DTR (data terminal\n        // ready) signal high to indicate to the device that the host is\n        // ready to send and receive data.\n        .then(() =&gt; this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x01,\n            'index': this.interfaceNumber_}))\n        .then(() =&gt; {\n          readLoop();\n        });\n  };\n\n  serial.Port.prototype.disconnect = function() {\n    // This request sets the DTR (data terminal ready) signal low to\n    // indicate to the device that the host has disconnected.\n    return this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x00,\n            'index': this.interfaceNumber_})\n        .then(() =&gt; this.device_.close());\n  };\n\n  serial.Port.prototype.send = function(data) {\n    return this.device_.transferOut(this.endpointOut_, data);\n  };\n})();\n</code></pre> <p>Images below show output and how it works:</p> <p></p> <p></p>"},{"location":"WebUSB_Findings/#software-creation-attempts","title":"Software Creation Attempts","text":"<p>This section tracks all attempts to get WebUSB working to integrate nicely with a webcam and an Arduino. </p>"},{"location":"WebUSB_Findings/#version-01-set-up-basic-web-interface-connect-communicate-with-arduino","title":"Version 0.1 \u2192 Set up basic web interface + Connect &amp; Communicate with Arduino","text":"<p>HTML code below: V1.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;WebUSB Interface&lt;/title&gt;\n&lt;/head&gt;\n&lt;body style=\"background:#111;color:white;font-family:sans-serif;text-align:center;padding:2em\"&gt;\n  &lt;h1&gt;\ud83d\udd0c Connect to Arduino&lt;/h1&gt;\n  &lt;button id=\"connect\"&gt;Connect&lt;/button&gt;\n  &lt;div id=\"status\"&gt;Status: Not connected&lt;/div&gt;\n  &lt;br&gt;&lt;input id=\"command\" placeholder=\"Enter command (e.g. Scanning Mode)\" /&gt;\n  &lt;button onclick=\"sendCommand()\"&gt;Send&lt;/button&gt;\n  &lt;pre id=\"log\"&gt;&lt;/pre&gt;\n\n  &lt;script&gt;\n    let device;\n    const status = document.getElementById(\"status\");\n    const log = document.getElementById(\"log\");\n\n    document.getElementById(\"connect\").onclick = async () =&gt; {\n      try {\n        device = await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2341 }] }); // update with your vendor ID\n        await device.open();\n        await device.selectConfiguration(1);\n        await device.claimInterface(2); // use correct interface #\n        status.innerText = \"Status: Connected\";\n        readLoop();\n      } catch (err) {\n        status.innerText = \"Status: Failed to connect\";\n        log.innerText += err + \"\\n\";\n      }\n    };\n\n    async function sendCommand() {\n      if (!device) return;\n      const cmd = document.getElementById(\"command\").value + \"\\n\";\n      const encoder = new TextEncoder();\n      await device.transferOut(4, encoder.encode(cmd)); // use correct endpoint\n    }\n\n    async function readLoop() {\n      while (device) {\n        const result = await device.transferIn(5, 64); // correct endpoint #\n        const decoder = new TextDecoder();\n        log.innerText += decoder.decode(result.data) + \"\\n\";\n      }\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Output Below: </p> <p></p> <p></p> <p>Ultimately, it didn't work out as well as expected, and all of it is most likely down to not having the Arduino set up properly to be able to recieve commands. It is able to recognize the Arduino, but the Arduino cannot recieve any of the messages that were sent. </p> <p>Putting aside everything related to connectivity, there are issues with getting the webcam to work on a basic web interface on html. This could mainly be because of the potential for security risks, and so browsers will tend to block access to the webcam. To emphasize, this is my belief based on my findings and testing. </p>"},{"location":"WebUSB_Findings/#version-02-build-webapp-hope-for-webcam-to-work","title":"Version 0.2 \u2192 Build Webapp + Hope for webcam to work","text":"<p>For this version, I created a virtual coding environment within VSCode and attempted to use Flask to set up a basic web interface and get the webcam and Arduino to talk to one another. </p> <p>Here is the python code:</p> appv2.py<pre><code>from flask import Flask, render_template, Response, request\nimport cv2\nfrom datetime import datetime\nimport threading\nimport time\nimport numpy as np\nfrom ultralytics import YOLO\nimport os\n\napp = Flask(__name__)\n\n# -------------------------\n# Config\n# -------------------------\nCAMERA_INDEX = 0\nLOG_FILE = \"log.txt\"\nMODEL_PATH = \"yolov8n.pt\"\n\n# -------------------------\n# State\n# -------------------------\ncap = cv2.VideoCapture(CAMERA_INDEX)\nmodel = YOLO(MODEL_PATH) if os.path.exists(MODEL_PATH) else None\ncurrent_mode = None\nlog_lock = threading.Lock()\ndetection_active = False\n\ndef log_message(message):\n    timestamp = datetime.now().strftime(\"[%H:%M:%S]\")\n    line = f\"{timestamp} {message}\\n\"\n    with log_lock:\n        with open(LOG_FILE, \"a\") as f:\n            f.write(line)\n\ndef gen_frames():\n    global detection_active\n    while True:\n        success, frame = cap.read()\n        if not success:\n            black_frame = (255 * np.zeros((480, 640, 3), dtype=np.uint8))\n            ret, buffer = cv2.imencode('.jpg', black_frame)\n            frame = buffer.tobytes()\n            yield (b'--frame\\r\\n'\n                   b'Content-Type: image/jpeg\\r\\n\\r\\n' + frame + b'\\r\\n')\n            continue\n\n        if detection_active and model:\n            results = model(frame)[0]\n            frame = results.plot()\n\n            # Handle modes\n            for box in results.boxes:\n                cls_id = int(box.cls[0])\n                class_name = model.names[cls_id]\n\n                if current_mode == \"scan\":\n                    log_message(f\"MODE Scanning Detected: {class_name}\")\n                elif current_mode == \"sort\":\n                    log_message(f\"MODE Sorting Detected: {class_name}\")\n                    break\n\n        ret, buffer = cv2.imencode('.jpg', frame)\n        frame = buffer.tobytes()\n        yield (b'--frame\\r\\n'\n               b'Content-Type: image/jpeg\\r\\n\\r\\n' + frame + b'\\r\\n')\n\n@app.route(\"/upload_model\", methods=[\"POST\"])\ndef upload_model():\n    global model\n    file = request.files[\"model\"]\n    if file and file.filename.endswith(\".pt\"):\n        path = os.path.join(\"models\", file.filename)\n        file.save(path)\n        model = YOLO(path)\n        log(f\"\u2705 Model loaded: {file.filename}\")\n        return \"\u2705 Model loaded successfully\"\n    return \"\u274c Invalid model file\"\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/video_feed')\ndef video_feed():\n    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')\n\nmode = \"stop\"\n\n@app.route('/set_mode/&lt;new_mode&gt;')\ndef set_mode(new_mode):\n    global mode\n    mode = new_mode\n    return f\"Mode set to {new_mode}\"\n\nlog_data = []\n\n@app.route('/log')\ndef get_log():\n    return \"\\n\".join(log_data[-50:])  # Keep only recent 50 lines\n\ndef log(message):\n    timestamp = datetime.now().strftime(\"%H:%M:%S\")\n    log_data.append(f\"[{timestamp}] {message}\")\n\nif __name__ == '__main__':\n    log_message(\"Flask Backend Started\")\n    app.run(host='0.0.0.0', port=5000, debug=True)\n</code></pre> <p></p> <p>Turns out the webcam doesn't really work here either... </p> <p>At this point, I have tried working with it and it ultimately did not work. At this point in the project timeline, I had made the decision to abandon the idea of programming a web interface and focus more on iterating through software that works and runs locally. Web development can be explored as an option, but is something I would consider to be \"out of scope\" for the project, but can be mentioned as a future improvements. </p>"},{"location":"WebUSB_Findings/#conclusion","title":"Conclusion","text":"<p>WebUSB is not ideal (from a simplicity point of view) due to the communication protocol that needs to be put in place. With any webpage, a client and server is needed. However, this communication would have to be extended to the Arduino as well. With a large amount of communication happening between the user, client, server, and Arduino, there is bound to be a loss of data somewhere due to data being sent and recieved from multiple sources, essentially overloading the system. While the ideal scenario would be to run something like this, my prototype will not be using a web-based system to reduce the complexity of communicating information.</p> <p>Click to go back to architecture page.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#software-considerations","title":"Software Considerations","text":"<p>Early in the project timeline, the focus for any architectural decisions was heavily biased towards the software, as there are many possibilities for the software, and significantly fewer physical prototype solutions. </p>"},{"location":"architecture/#early-software-decisions","title":"Early Software Decisions","text":"<p>Given that the project solution requires a cyberphysical system, it is best to work with some kind of microcontroller. In addition, since laptops can vary with processing power, age, graphics performance, etc, it is best to utilize a solution that is lighter on a laptop. The goal here is to have as many devices as possible be able to run the software. </p> <p>This is where the first major pathway to a solution arrives: using WebUSB. WebUSB is an API that allows certain compatible microcontrollers to be able to communicate to a web browser. This would open up the potential for users to be able to interact with the Arduino using an HTML file. Keeping this solution on a web browser would be able to allow the system to run much lighter.</p> <p>Such a solution can be seen with Google's Tiny Sorter, which is primarily used as a teaching tool to help people learn about computer vision and sorting. One of the main drawbacks about this solution is that it doesn't accomodate for a variety of object types, and would be difficult to sort larger and heavier objects. It also does not allow a user to input a pretrained model, and instead relies on the end user to train the system. If done improperly, or in bad lighting, then the model produced is not as accurate.</p> <p>This led me down a rabbit hole of using WebUSB and getting my hands on an Arduino Leonardo, which is a WebUSB-compatible Arduino. My findings about WebUSB are laid out in more detail here. Note that this page can also be found by navigating via the development section, so you can view it then as well.</p> <p>Long story short, WebUSB is not ideal (from a simplicity point of view) due to the communication protocol that needs to be put in place. With any webpage, a client and server is needed. However, this communication would have to be extended to the Arduino as well. With a large amount of communication happening between the user, client, server, and Arduino, there is bound to be a loss of data somewhere due to data being sent and recieved from multiple sources, essentially overloading the system. While the ideal scenario would be to run something like this, my prototype will not be using a web-based system to reduce the complexity of communicating information. </p>"},{"location":"architecture/#final-software-decisions","title":"Final Software Decisions","text":"<p>Based on the information outlined above, I have chosen to run the program locally. A graphical user interface (GUI) will be built via Python, which will also handle communication to and from the Arduino via a serial communication port. </p> <p>The GUI will allow the user to dictate what gets done and when as well as monitor the whole system and provide that information to the user. A GUI can be constructed in many ways, however, I have chosen to use tkinter for Python. </p> <p>Communication to and from the Arduino via a serial communication port is a good option as it allows data to be sent to and from using one channel, whereas using WebUSB would mean data has to transfer from client to server to Arduino. </p> <p>More technical details can be seen on the development pages, where the software versions are outlined as I iterate through them towards a working solution. </p>"},{"location":"architecture/#prototype-considerations-work-in-progress","title":"Prototype Considerations (WORK IN PROGRESS)","text":""},{"location":"architecture/#early-prototype-decisions","title":"Early Prototype Decisions","text":"<p>Early on, the choice had to be made to decide whether to design a prototype that works well with one kind of object or womething that won't work as well but can support a varierty of objects. </p> <p>Initially, I thought about going with the former. Coins are something that a lot of people have at their homes, including myself, and I thought testing using that would be great. I had initially wanted to design a system that works really well with coins, but coins only. However, it is more ideal to use a system that can support a variety of objects, even at reduced ability and capacity, as it allows for a proper proof of concept to be established with a relatively universal solution.</p> <p>There are more things that need to be figured out before designing any prototype:</p> <ul> <li>How are objects fed into system?</li> <li>What happens if the user cannot feed objects one-by-one? How does the system handle this?</li> <li>How can the system detect the objects in a webcam? Should a box be built around the webcam and an LED to illuminate it or is there another solution?</li> <li>What mode of movement should objects use when sending an object to the webcam and from the webcam to the bin?</li> <li>etc...</li> </ul>"},{"location":"architecture/#final-prototype-decisions","title":"Final Prototype Decisions","text":"<p>Here are some answers to some of the questions I posed above?</p> <ul> <li>How are objects fed into system? \u2192 They can be fed one by one or ideally, through some kind of feeder, either vibration based or centrifugal.</li> <li>What happens if the user cannot feed objects one-by-one? How does the system handle this? \u2192 Using something like a feeder can allow objects to be fed more uniformly, regardless of how the user would load the objects.</li> <li>How can the system detect the objects in a webcam? Should a box be built around the webcam and an LED to illuminate it or is there another solution? \u2192 ....</li> <li>What mode of movement should objects use when sending an object to the webcam and from the webcam to the bin? \u2192 ....</li> </ul>"},{"location":"intro/","title":"Introduction and Motivation","text":"<p>When a bullet is fired at a crime scene it leaves behind a casing and the bullet itself. The bullet size varies depending on the gun that is being used, but each bullet contains a unique identification that can be traced back to a specific gun that it was fired with. There is currently a relatively outdated process in place, whereby an examiner will have to manually measure and identify markings. While more advanced versions of this technique can be used (standards determined by NIST), it still heavily relies on an examiner going through. While human input can be deemed necessary, it is an inefficient process that can be streamlined if the bullets were able to be somehow pre-sorted. This would save time and make the process more efficient. </p> <p>Designing a new device would also require engineers to justify the need for such a product, and also delve into how it can be used in other applications. There are similar existing problems in other applications. An example of such an application would be coin sorting. If there were 1000 assorted coins of differing currencies, it would be possible to sort by hand albeit through a lengthy procedure. Another example is in an agricultural setting, where one would have to maybe sort through 2-3 different types of beans efficiently. Other examples include but are not limited to: various assorted electrical components (resistors, op-amps, capacitors, etc), assorted LEGOs, and assorted perler beads. </p> <p>An ideal device would be able to use an image of the product, identify what it is, and sort it based on the context of what would be coming into the device. This type of device can be designed using machine learning (ML), which is trained using images of a certain category. Note that this is a simplified version of the pipeline, and a more detailed pipeline will be ironed out in later phases of the design and prototyping process. There are various pros and cons to using ML in such an application, with the biggest pro being the ability to make an inefficient process more efficient and the biggest con being that the ability of the device functioning properly depends entirely on how well the ML implementation is done. </p> <p>To my knowledge, there is not such a device in the market, but there are aspects of the solution that are working in the market, and serve as a proof of concept. The first of these are a series of apps that are able to use the image of a coin to be able to give relevant information to the user. An example of such an app is \u201cCoinSnap\u201d, which allows users to scan coins and be provided with information and facts about that specific coin. This idea can be extended to similar apps on a smartphone for different purposes, such as identifying stars in the night sky or even forms of wildlife. </p> <p>A second working proof of concept serves as a working example of such a device. A company called Bulher has created a sorting device that can sort things such as agricultural seeds, coffee beans, etc in their \u201cSORTEX\u201d lineup. The device uses an optical sensor to be able to sort out a sample given the respective categories. </p> <p>But what if there was a solution that was more modular, something that could plug into a laptop and leverage its webcam to be able to physically sort through objects, not just identify them?</p> <p>References:</p> <p>Market Research:</p> <ul> <li> <p>Want to \u201cchange\u201d your fortune? Coin apps might help \u2192 Apps that take image of coins and are able to figure out its value</p> </li> <li> <p>GitHub - thim0o/CoinDetector \u2192 An image based coin counter using Python and Tensorflow Coin Detector on GitHub</p> </li> <li> <p>Optical Sorting Machines \u2192 Working Concept within Agriculture</p> </li> </ul> <p>Publications:</p> <ul> <li>Cell.com |  Intelligent Image-Activated Cell Sorting</li> <li>Nanocellect | Image-guided cell sorting technical overview</li> </ul>"},{"location":"milestones/","title":"Milestones","text":"<p>This page will contain a bit of information about each milestone as shown on the main page, including some of the goals of each, and if applicable, anything I have done to ensure that the milestone will be marked as \"complete\". For example, for testing, this page will contain information about any initially planned test runs, but will not cover the results. For more details descriptions of the architecture, design, testing, etc, view those respective pages in the navigation. </p>"},{"location":"milestones/#1-refresh-programming-knowledge","title":"1. Refresh Programming Knowledge","text":"<p>Based on my personal experiences, this phase of the project was more of a refresher for me. However, someone with less background with coding, in my opinion, should go through some coding lessons online and/or take a class. </p> <p>Prior to starting this project, I had used the following:</p> <ul> <li>Java</li> <li>MATLAB</li> <li>Python</li> <li>Arduino IDE</li> </ul> <p>Java was the first programming language I had learned, and I had done so in a more formal way by taking a course during my second semester of my undergrad. This class taught me the basics of Object Oriented Programming, and I was tasked with a variety of assignments with each one getting more complicated. I had learned the basics of everything from writing my first program to loops to client and server code. In addition, I had to work through a project at the end of the semester, where I worked with a team to code a basic learning interface similar to Canvas and Brightspace. </p> <p>I next learned MATLAB, which I used to complete the bulk of my engineering assignments during the first year engineering (FYE) curriculum that Purdue has in place. </p> <p>From there, I learned Python, also by taking a class at Purdue (EBEC 101). Here, I used Python in a traditional sense, by completing relatively simple assignments that taught me the basics of coding, but instead entirely in Python. </p> <p>After that, I learned how to program Arduinos using the Arduino IDE, albeit in a more nontraditional sense where I was introduced to everything in a more practical sense, and have since fine tuned my abilities through project-based learning. </p> <p>That being said, I had a decent background when it came to coding, so a few lessons in Python from YouTube were enough to get me going again and ready to learn more.</p> <p>For someone looking to replicate this, I would strongly suggest learning Python, as that is the programming language that is used throughout this project, as well as learning the basics behind working with Arduinos and familiarity with the IDE. I will also be using PlatformIO to run my project entirely in VSCode instead of using two different IDEs.</p>"},{"location":"milestones/#2-understand-basics-of-machine-learning","title":"2. Understand Basics of Machine Learning","text":"<p>Prior to starting this project, I had zero experience with Machine Learning. This is what I did to familiarize myself with the basics of ML. I ended up taking free online classes to refresh my Python knowledge and expand that understanding into machine learning. Links to the classes are below, with certificates on my LinkedIn page.</p> <ul> <li>Machine Learning with Python course | Cognitive Class</li> <li>Data Visualization with Python course | Cognitive Class</li> <li>Python for Data Science course | Cognitive Class</li> <li>Predictions: Regression for Car Mileage and Diamond Price</li> <li>Customer Clustering with KMeans to Boost Business Strategy</li> <li>Precise Predictions: Classification for Flower and Tumors</li> </ul> <p>While this is not by any means a guide to learning machine learning, the emphasis for this project was to familiarize myself with it and get better at implementing it as I progress through this project. </p>"},{"location":"milestones/#3-develop-basic-software","title":"3. Develop Basic Software","text":"<p>Developing basic software entails having code up and running for the software side of this project, which entails mainly getting YOLO working as well as setting up the interface and all basic functions that need to be in place for this to be successful. At the minimum, here is what is expected:</p> <ul> <li>Be intuitive to use, and look somewhat polished</li> <li>Allow user to perform basic functions</li> <li>Allow user control over the process</li> <li>At the minimum, recognize when an Arduino is connected via USB to laptop</li> <li>Leverage webcam to detect objects</li> <li>Have some error handling in place and prevent user from going too far out of order</li> </ul>"},{"location":"milestones/#4-3d-model-and-design-physical-product","title":"4. 3D Model and Design Physical Product","text":"<p>The goal here is to design a minimum viable prototype, where the parts and system is able to work adequately well and a well established proof of concept is present. At the minimum, here is what is expected:</p> <ul> <li>Be simple to use for the end user</li> <li>Allow user to perform basic functions, notably loading and sorting objects under supervision with minimal human intervention</li> <li>Allow user to load a small to medium number of items for sorting, mainly for testing purposes</li> <li>Objects should get sorted into 2 bins, where one is the target and the other is not the target, hence the \"binary\" aspect of the sorter</li> <li>Keep costs as low as possible, with the aim to be reproducible</li> </ul>"},{"location":"milestones/#5-integrate-software-and-hardware","title":"5. Integrate Software and Hardware","text":"<p>Once basic software and working prototype are set up, work needs to be done to integrate the software and prototype made earlier. Here, the different modes will be properly established:</p> <ul> <li>Object Detection Mode: Here, objects will pass through the mechanical system in place and not do any kind of sorting. The goal is to detect a list of unique objects so that the number of passes the system requires can be established.</li> <li>Object Sorting Mode: Here, objects will be sorted through the system, with motors/actuators being used to facilitate the sorting process.</li> </ul> <p>At this point, small scale testing will be carried out. The aim here is to get around 10-20 objects with at least 3 unique classes of objects properly sorted. </p>"},{"location":"milestones/#6-final-testing","title":"6. Final Testing","text":"<p>At this point, the system is well established, and the testing can be slightly scaled up. In addition, different models will be tested to ensure that the system is more \"plug and play\", where the end user will be able to train or load in a pytorch model to be used with YOLO.</p>"},{"location":"milestones/#7-reflection-and-next-steps","title":"7. Reflection and Next Steps","text":"<p>Reflections will be made here to discuss flaws of working prototype as well as a path forward should the project timeline be extended.</p>"},{"location":"progress/","title":"Project Progress","text":"Refresh Programming Knowledge Understand Basics of Machine Learning Develop Basic Software 3D Model and Design Physical Product Integrate Software and Hardware Final Testing Reflection and Next Steps"},{"location":"software_development/","title":"Software Development Overview","text":"<p>This section of the website is dedicated to getting a minimum viable software developed, before truly getting it integrated in context to the whole system. The software was developed before any physical prototype was designed or assembled. </p> <p>View the progression through the software development via the collapsible menu on the left. </p>"},{"location":"software_v1/","title":"Version 1 (Intermediate)","text":""},{"location":"software_v1/#brief-intro-and-technical-details","title":"Brief Intro and Technical Details","text":"<p>This page outlines the first attempt at developing a python app to be controlled by the user via a GUI. </p> <p>Here is a quick overview of the software:</p> <ul> <li>Scanning Mode \u2192 Scans all objects that need to be sorted, with a list of unique objects stored in a .csv file.</li> <li>Sorting Mode \u2192 Sorts the objects</li> </ul> <p>Here is a quick overview of the key features:</p> <ul> <li>Object Detection \u2192 Done by utilizing webcam and YOLO; users can select a PyTorch model to be used</li> <li>Object Logging \u2192 Stores list of unique objects in csv to be read by Arduino; objects also stored in Arduino's EEPROM in case system powers off</li> <li>User Control \u2192 User dictates when the software does what</li> <li>Arduino Recognition \u2192 Software knows when Arduino is connected and will not start scanning or sorting until then</li> <li>Error Handling \u2192 Some error checking is in place</li> </ul> <p>How does this compare to the requirements laid out on the milestones page?</p> Requirement from Milestone 3 Status Notes (if needed) Be intuitive to use, and look somewhat polished \u274c GUI is intuitive, but very dated Allow user to perform basic functions \ud83d\udcad Detection and scanning good, but sorting framework not set in place Allow user control over the process \u2705 User dictates entire process, minus the actual object detection At the minimum, recognize when an Arduino is connected via USB to laptop \ud83d\udcad System can recognize AND communicate with Arduino, but framework to sort is not in place Leverage webcam to detect objects \u2705 Utilizes YOLO and webcam to detect objects, with bounding boxes serving as visual confirmation Have some error handling in place and prevent user from going too far out of order \u2705 Error handling present <p>What is missing with this version?</p> <ul> <li>Object Sorting Theory \u2192 Sorting Mode can be engaged but beyond that, there is not much structure for how the objects will be sorted. Binary sorting makes the most sense in this application and will be developed in the next version.</li> <li>User Interface \u2192 Interface using tkinter for Python was a great idea, but has a very dated appearance </li> <li>Arduino Functionality \u2192 Arduino is equipped to identify when sorting has started, but does not have the proper framework in place to be able to control motors.</li> </ul>"},{"location":"software_v1/#code","title":"Code","text":"<p>Since this is an intermediate version of the software, with a better version in place, the code for the GUI and Arduino will be provided here as well as screenshots of the appearance of the software. A video of the software working will be provided on the next version's page, with error handling, user control, etc on full display. </p> <p>Python Code: <pre><code>import tkinter as tk\nfrom tkinter import ttk, filedialog\nfrom PIL import Image, ImageTk\nimport cv2\nfrom ultralytics import YOLO\nimport csv\nimport os\nimport serial\nimport threading\nfrom datetime import datetime\nimport serial.tools.list_ports\nimport time\nimport csv\nfrom PIL import ImageDraw, ImageFont\n\n# ---------------------------\n# CONFIGURATION\n# ---------------------------\nCAMERA_INDEX = 0\nWINDOW_TITLE = \"YOLO-Based Binary Object Sorting System V1\"\nWINDOW_BG_COLOR = \"#1e1e1e\"\nFRAME_RATE_MS = 15\nLOG_DIR = \"logs\"\n\n# ---------------------------\n# Ensure Logs Folder Exists\n# ---------------------------\nos.makedirs(LOG_DIR, exist_ok=True)\n\ndef generate_csv_name():\n    now = datetime.now()\n    return f\"{LOG_DIR}/scan_log_{now.strftime('%Y-%m-%d_%H-%M-%S')}.csv\"\n\n# ---------------------------\n# Connection to Arduino\n# ---------------------------\n\ndef find_arduino_port():\n    ports = serial.tools.list_ports.comports()\n    for port in ports:\n        if \"Leonardo\" in port.description or (port.vid == 0x2341 and port.pid == 0x8036):\n            return port.device\n    return None\n\ndef reset_arduino_before_exit(port):\n    try:\n        ser = serial.Serial(port, 1200)\n        ser.close()\n        print(\"\ud83d\uded1 Arduino reset triggered\")\n        time.sleep(2)  # wait for Arduino to fully reset\n    except Exception as e:\n        print(f\"\u26a0\ufe0f Could not reset Arduino: {e}\")\n\ndef get_unique_classes_from_csv(path):\n    unique_classes = set()\n    try:\n        with open(path, newline='') as f:\n            reader = csv.reader(f)\n            for row in reader:\n                if len(row) &gt;= 2:\n                    unique_classes.add(row[1])\n    except Exception as e:\n        print(f\"Error reading CSV: {e}\")\n    return list(unique_classes)\n\ndef send_objects_to_eeprom(item_list, arduino_serial):\n    try:\n        # Create comma-separated string\n        object_string = \",\".join(item_list[:20])  # Limit to 20 items\n\n        # Send the command\n        command = f\"STORE_OBJECTS:{object_string}\\n\"\n        arduino_serial.write(command.encode())\n\n        print(f\"\u2705 Sent {len(item_list)} objects to Arduino EEPROM\")\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Failed to send objects: {e}\")\n        return False\n\n# ---------------------------\n# GUI Class\n# ---------------------------\nclass YOLOApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(WINDOW_TITLE)\n        self.root.configure(bg=WINDOW_BG_COLOR)\n        self.arduino = None\n\n        self.cap = cv2.VideoCapture(CAMERA_INDEX)\n        if not self.cap.isOpened():\n            raise RuntimeError(\"\u274c Cannot open webcam\")\n\n        self.is_running = False\n        self.mode = None  # 'scan' or 'sort'\n        self.csv_file = None\n        self.detected_classes = set()\n        self.model_path = \"\"\n        self.model = None\n        self.arduino_ready_to_sort = False\n\n        # Layout frames\n        main_frame = tk.Frame(root, bg=WINDOW_BG_COLOR)\n        main_frame.pack(fill=tk.BOTH, expand=True)\n\n        left_frame = tk.Frame(main_frame, bg=WINDOW_BG_COLOR)\n        left_frame.pack(side=tk.LEFT, padx=10, pady=10)\n\n        right_frame = tk.Frame(main_frame, bg=WINDOW_BG_COLOR)\n        right_frame.pack(side=tk.RIGHT, padx=10, pady=10, fill=tk.Y)\n\n        # Video Frame\n        self.video_frame = tk.Label(left_frame)\n        self.video_frame.pack()\n\n        # Create a black placeholder with text \"Camera Offline\"\n        placeholder = Image.new(\"RGB\", (640, 480), (0, 0, 0))\n        draw = ImageDraw.Draw(placeholder)\n\n        try:\n            font = ImageFont.truetype(\"arial.ttf\", 36)\n        except:\n            font = ImageFont.load_default()\n\n        text = \"CAMERA OFFLINE\"\n        bbox = draw.textbbox((0, 0), text, font=font)\n        text_width = bbox[2] - bbox[0]\n        text_height = bbox[3] - bbox[1]\n        position = ((640 - text_width) // 2, (480 - text_height) // 2)\n        draw.text(position, text, fill=(200, 200, 200), font=font)\n\n        self.placeholder_img = ImageTk.PhotoImage(placeholder)\n        self.video_frame.configure(image=self.placeholder_img)\n        self.video_frame.imgtk = self.placeholder_img\n\n        # Control Buttons\n        btn_frame = tk.Frame(left_frame, bg=WINDOW_BG_COLOR)\n        btn_frame.pack(pady=10)\n\n        self.choose_model_btn = ttk.Button(btn_frame, text=\"Choose PyTorch Model\", command=self.choose_model)\n        self.choose_model_btn.grid(row=0, column=0, padx=5)\n\n        self.arduino_btn = ttk.Button(btn_frame, text=\"Connect to Arduino\", command=self.connect_to_arduino)\n        self.arduino_btn.grid(row=0, column=1, padx=5)\n\n        self.scan_btn = ttk.Button(btn_frame, text=\"\ud83d\udcf8 Start Scanning Mode\", command=self.start_scanning_mode)\n        self.scan_btn.grid(row=0, column=2, padx=5)\n\n        self.sort_btn = ttk.Button(btn_frame, text=\"\u2699\ufe0f Start Sorting Mode\", command=self.start_sorting_mode)\n        self.sort_btn.grid(row=0, column=3, padx=5)\n\n        self.stop_btn = ttk.Button(btn_frame, text=\"\u23f9 Stop\", command=self.stop_detection)\n        self.stop_btn.grid(row=0, column=4, padx=5)\n\n        # Second row of buttons\n        self.send_list_btn = ttk.Button(btn_frame, text=\"\ud83d\udcc2 Send Object List to Arduino\", command=self.send_object_list)\n        self.send_list_btn.grid(row=1, column=0, columnspan=2, pady=10, padx=5)\n\n        self.list_objects_btn = ttk.Button(btn_frame, text=\"\ud83d\udccb List Stored Objects\", command=self.list_stored_objects)\n        self.list_objects_btn.grid(row=1, column=2, padx=5)\n\n        self.clear_objects_btn = ttk.Button(btn_frame, text=\"\ud83d\uddd1\ufe0f Clear Objects\", command=self.clear_stored_objects)\n        self.clear_objects_btn.grid(row=1, column=3, padx=5)\n\n        exit_button = ttk.Button(btn_frame, text=\"Exit\", command=self.exit_app)\n        exit_button.grid(row=1, column=4, padx=5)\n\n        # Output Log\n        self.log_text = tk.Text(right_frame, width=40, height=30, bg=\"black\", fg=\"white\", wrap=tk.WORD)\n        self.log_text.pack(fill=tk.BOTH, expand=True)\n        self.log(\"\ud83d\udfe2 GUI Initialized\")\n\n        # ---------------------------\n        # \ud83c\udfa8 Button Styling\n        # ---------------------------\n        style = ttk.Style()\n        style.theme_use(\"default\")\n        style.configure(\"TButton\", background=\"#444\", foreground=\"white\", padding=6, font=(\"Segoe UI\", 10, \"bold\"))\n        style.map(\"TButton\", background=[(\"active\", \"#777\")])\n\n    # ---------------------------\n    # \ud83e\uddfe Log Output\n    # ---------------------------\n    def log(self, message):\n        timestamp = datetime.now().strftime(\"[%H:%M:%S]\")\n        self.log_text.insert(tk.END, f\"{timestamp} {message}\\n\")\n        self.log_text.see(tk.END)\n\n    # ---------------------------\n    # \ud83d\udea6 MODE SWITCHING\n    # ---------------------------\n    def start_scanning_mode(self):\n        if self.mode == \"scan\":\n            self.stop_detection()\n            return\n\n        if self.model is None:\n            self.log(\"\u26a0\ufe0f No model selected\")\n            return\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n            return\n\n        self.stop_detection()\n        self.mode = \"scan\"\n        self.scan_btn.config(text=\"\u23f9 Stop Scanning Mode\", state=tk.NORMAL)\n        self.sort_btn.config(state=tk.DISABLED)\n        self.csv_file = generate_csv_name()\n        self.detected_classes.clear()\n        self.log(f\"\ud83d\udcc4 Logging to: {self.csv_file}\")\n        self.is_running = True\n        self.update_frame()\n\n    def start_sorting_mode(self):\n        if self.mode == \"sort\":\n            self.stop_detection()\n            return\n        if self.model is None:\n            self.log(\"\u26a0\ufe0f No model selected\")\n            return\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n            return\n        if not self.arduino_ready_to_sort:\n            self.log(\"\u274c Arduino is not ready. Send object list first.\")\n            return\n        self.stop_detection()\n        self.mode = \"sort\"\n        self.sort_btn.config(text=\"\u23f9 Stop Sorting Mode\", state=tk.NORMAL)\n        self.scan_btn.config(state=tk.DISABLED)\n        self.log(\"\u2699\ufe0f Sorting mode active\")\n        self.is_running = True\n        self.update_frame()\n\n    def stop_detection(self):\n        self.is_running = False\n        was_sorting = (self.mode == \"sort\")  # Remember if we were sorting\n        self.mode = None\n        self.video_frame.configure(image=self.placeholder_img)\n        self.video_frame.imgtk = self.placeholder_img\n        self.scan_btn.config(text=\"\ud83d\udcf8 Start Scanning Mode\", state=tk.NORMAL)\n        self.sort_btn.config(text=\"\u2699\ufe0f Start Sorting Mode\", state=tk.NORMAL)\n\n        # Send stop command to Arduino\n        self.send_to_arduino(\"stop\")\n\n        if was_sorting:\n            self.log(\"\ud83d\uded1 Detection stopped - Sorting mode disabled\")\n        else:\n            self.log(\"\ud83d\uded1 Detection stopped\")\n\n    def choose_model(self):\n        if self.is_running:\n            self.log(\"\u26a0\ufe0f Stop detection before loading a new model\")\n            return\n        path = filedialog.askopenfilename(filetypes=[(\"PyTorch Model\", \"*.pt\")])\n        if path:\n            self.model_path = path\n            self.model = YOLO(self.model_path)\n            self.log(f\"\u2705 Model loaded: {self.model_path}\")\n\n    # ---------------------------\n    # Frame Processing\n    # ---------------------------\n    def update_frame(self):\n        if not self.is_running:\n            return\n\n        ret, frame = self.cap.read()\n        if not ret:\n            self.log(\"\u274c Failed to grab frame - stopping detection\")\n            self.stop_detection()  # Auto-stop if camera fails\n            return\n\n        results = self.model(frame)[0]\n        annotated = results.plot()\n\n        if self.mode == \"scan\":\n            self.handle_scanning_mode(results)\n        elif self.mode == \"sort\":\n            self.handle_sorting_mode(results)\n\n        rgb_frame = cv2.cvtColor(annotated, cv2.COLOR_BGR2RGB)\n        img = Image.fromarray(rgb_frame)\n        imgtk = ImageTk.PhotoImage(image=img)\n        self.video_frame.imgtk = imgtk\n        self.video_frame.configure(image=imgtk)\n\n        self.root.after(FRAME_RATE_MS, self.update_frame)\n\n    # ---------------------------\n    # Scanning Mode Logic\n    # ---------------------------\n    def handle_scanning_mode(self, results):\n        self.send_to_arduino(\"scan\")\n        for box in results.boxes:\n            cls_id = int(box.cls[0])\n            class_name = self.model.names[cls_id]\n            if class_name not in self.detected_classes:\n                self.detected_classes.add(class_name)\n                with open(self.csv_file, 'a', newline='') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([datetime.now().isoformat(), class_name])\n                self.log(f\"\ud83d\udcdd Logged: {class_name}\")\n\n    # ---------------------------\n    # Sorting Mode Logic\n    # ---------------------------\n    def handle_sorting_mode(self, results):\n        self.send_to_arduino(\"sort\")\n        for box in results.boxes:\n            cls_id = int(box.cls[0])\n            class_name = self.model.names[cls_id]\n            self.log(f\"\ud83d\udce6 Detected for sorting: {class_name}\")\n            # Send the detected class to Arduino\n            self.send_to_arduino(class_name)\n            break\n\n    # ---------------------------\n    # Arduino Communication\n    # ---------------------------\n\n    def connect_to_arduino(self):\n        port = find_arduino_port()\n        if port:\n            try:\n                self.arduino = serial.Serial(port, 9600, timeout=2)\n                self.log(f\"\ud83d\udfe1 Connecting to Arduino on {port}...\")\n\n                time.sleep(2)  # Allow time for Arduino to reset and send handshake\n\n                # Wait for \"READY\"\n                start_time = time.time()\n                ready_line = \"\"\n                while time.time() - start_time &lt; 5:\n                    if self.arduino.in_waiting &gt; 0:\n                        ready_line = self.arduino.readline().decode().strip()\n                        if ready_line == \"READY\":\n                            break\n                        elif ready_line:  # Any other message from Arduino\n                            self.log(f\"Arduino: {ready_line}\")\n\n                if ready_line == \"READY\":\n                    self.log(\"\u2705 Arduino is ready!\")\n                    self.arduino_btn.config(text=\"Arduino Connected!\", state=tk.DISABLED)\n\n                    # Start listening thread for Arduino messages\n                    self.start_arduino_listener()\n                else:\n                    self.log(f\"\u274c Unexpected handshake message: {ready_line}\")\n            except serial.SerialException as e:\n                self.log(f\"\u274c Connection Failed: {str(e)}\")\n        else:\n            self.log(\"\u26a0\ufe0f No Arduino found!\")\n\n    def start_arduino_listener(self):\n        \"\"\"Start a background thread to listen for Arduino messages\"\"\"\n        def listen():\n            while self.arduino and self.arduino.is_open:\n                try:\n                    if self.arduino.in_waiting &gt; 0:\n                        message = self.arduino.readline().decode().strip()\n                        if message:\n                            if message == \"READY_TO_SORT\":\n                                self.arduino_ready_to_sort = True\n                                self.log(\"\ud83d\udfe2 Arduino ready to sort!\")\n                            else:\n                                self.log(f\"Arduino: {message}\")\n                    time.sleep(0.1)\n                except Exception as e:\n                    if self.arduino and self.arduino.is_open:\n                        self.log(f\"Error reading from Arduino: {e}\")\n                    break\n\n        listener_thread = threading.Thread(target=listen, daemon=True)\n        listener_thread.start()\n\n    def send_to_arduino(self, message):\n        try:\n            if self.arduino and self.arduino.is_open:\n                self.arduino.write((message + \"\\n\").encode())\n        except Exception as e:\n            self.log(f\"\u274c Error sending to Arduino: {e}\")\n\n    def send_object_list(self):\n        \"\"\"Send object list to Arduino EEPROM\"\"\"\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u26a0\ufe0f Arduino must be connected before sending list\")\n            return\n\n        filepath = filedialog.askopenfilename(filetypes=[(\"CSV Files\", \"*.csv\")])\n        if not filepath:\n            self.log(\"\u26a0\ufe0f No file selected\")\n            return\n\n        classes = get_unique_classes_from_csv(filepath)\n        if not classes:\n            self.log(\"\u26a0\ufe0f No valid objects found in CSV\")\n            return\n\n        self.log(f\"\ud83d\udce4 Sending {len(classes)} objects to Arduino EEPROM...\")\n\n        if send_objects_to_eeprom(classes, self.arduino):\n            self.log(f\"\u2705 Sent {len(classes)} objects: {', '.join(classes)}\")\n        else:\n            self.log(\"\u274c Send failed\")\n\n    def list_stored_objects(self):\n        \"\"\"Ask Arduino to list stored objects\"\"\"\n        if self.arduino and self.arduino.is_open:\n            self.send_to_arduino(\"LIST_OBJECTS\")\n        else:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n\n    def clear_stored_objects(self):\n        \"\"\"Clear objects from Arduino EEPROM\"\"\"\n        if self.arduino and self.arduino.is_open:\n            self.send_to_arduino(\"CLEAR_OBJECTS\")\n            self.arduino_ready_to_sort = False\n            self.log(\"\ud83d\uddd1\ufe0f Cleared stored objects\")\n        else:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n\n    def exit_app(self):\n        if self.arduino and self.arduino.is_open:\n            port = self.arduino.port\n            self.arduino.close()\n            self.clear_stored_objects()\n            reset_arduino_before_exit(port)\n        self.root.destroy()\n\n# ---------------------------\n# Run GUI\n# ---------------------------\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    app = YOLOApp(root)\n    root.mainloop()\n\n    if app.cap.isOpened():\n        app.cap.release()\n    cv2.destroyAllWindows()\n</code></pre></p> <p>Arduino Code: <pre><code>#include &lt;Arduino.h&gt;\n#include &lt;EEPROM.h&gt;\n\nconst uint8_t MAX_ITEMS = 30;\nconst uint8_t MAX_STR_LEN = 50;\nconst int EEPROM_START_ADDR = 0;\nconst int NUM_ITEMS_ADDR = 0;\nconst int ITEMS_START_ADDR = 1;\n\nString storedItems[MAX_ITEMS];\nuint8_t numStoredItems = 0;\nString currentMode = \"\";\nString lastModeMessage = \"\";\nunsigned long lastModeTime = 0;\nconst unsigned long MODE_MESSAGE_COOLDOWN = 5000; // 5 seconds between mode messages\nbool itemsLoaded = false;\n\nvoid storeObjectsInEEPROM(String objects[], uint8_t count) {\n  // Store number of items first\n  EEPROM.write(NUM_ITEMS_ADDR, count);\n\n  int addr = ITEMS_START_ADDR;\n\n  for (uint8_t i = 0; i &lt; count; i++) {\n    String item = objects[i];\n\n    // Store length of string\n    uint8_t len = min(item.length(), (unsigned int)(MAX_STR_LEN - 1));\n    EEPROM.write(addr, len);\n    addr++;\n\n    // Store the string characters\n    for (uint8_t j = 0; j &lt; len; j++) {\n      EEPROM.write(addr, item[j]);\n      addr++;\n    }\n\n    // Fill remaining space with zeros\n    for (uint8_t j = len; j &lt; MAX_STR_LEN - 1; j++) {\n      EEPROM.write(addr, 0);\n      addr++;\n    }\n  }\n\n  Serial.println(\"\u2705 Objects stored in EEPROM\");\n}\n\nvoid loadObjectsFromEEPROM() {\n  numStoredItems = EEPROM.read(NUM_ITEMS_ADDR);\n\n  // Sanity check\n  if (numStoredItems &gt; MAX_ITEMS) {\n    numStoredItems = 0;\n    Serial.println(\"\u26a0\ufe0f Invalid EEPROM data, resetting\");\n    return;\n  }\n\n  if (numStoredItems == 0) {\n    Serial.println(\"\ud83d\udced No objects stored in EEPROM\");\n    return;\n  }\n\n  int addr = ITEMS_START_ADDR;\n\n  for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n    uint8_t len = EEPROM.read(addr);\n    addr++;\n\n    if (len &gt;= MAX_STR_LEN) len = 0; // Corrupted data\n\n    String item = \"\";\n    for (uint8_t j = 0; j &lt; len; j++) {\n      char c = EEPROM.read(addr);\n      if (c != 0) item += c;\n      addr++;\n    }\n\n    // Skip remaining bytes for this item\n    addr += (MAX_STR_LEN - 1 - len);\n\n    storedItems[i] = item;\n  }\n\n  if (numStoredItems &gt; 0) {\n    itemsLoaded = true;\n    Serial.println(\"\ud83d\udce5 Objects loaded from EEPROM:\");\n    for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n      Serial.print(\"  \");\n      Serial.println(storedItems[i]);\n    }\n    Serial.println(\"READY_TO_SORT\");\n  }\n}\n\nString lastSortedItem = \"\";\nunsigned long lastSortTime = 0;\nconst unsigned long SORT_COOLDOWN = 2000; // 2 seconds between same item sorts\n\nvoid handleSorting(String itemClass) {\n  unsigned long currentTime = millis();\n\n  // Only process if it's a different item or enough time has passed\n  if (itemClass != lastSortedItem || (currentTime - lastSortTime) &gt; SORT_COOLDOWN) {\n    Serial.print(\"\ud83d\udd04 Sorting item: \");\n    Serial.println(itemClass);\n\n    if (itemClass == \"bottle\") {\n      // trigger servo for bottle\n      Serial.println(\"\u2192 Sorting bottle\");\n    } else if (itemClass == \"can\") {\n      // another action for can\n      Serial.println(\"\u2192 Sorting can\");\n    } else if (itemClass == \"apple\") {\n      // action for apple\n      Serial.println(\"\u2192 Sorting apple\");\n    } else {\n      Serial.println(\"\u2753 Unknown class, default action\");\n    }\n\n    lastSortedItem = itemClass;\n    lastSortTime = currentTime;\n  }\n}\n\nvoid processObjectList(String objectListString) {\n  // Parse comma-separated string\n  String tempItems[MAX_ITEMS];\n  uint8_t count = 0;\n\n  int startIdx = 0;\n  int commaIdx = objectListString.indexOf(',');\n\n  while (commaIdx != -1 &amp;&amp; count &lt; MAX_ITEMS) {\n    tempItems[count] = objectListString.substring(startIdx, commaIdx);\n    tempItems[count].trim();\n    count++;\n\n    startIdx = commaIdx + 1;\n    commaIdx = objectListString.indexOf(',', startIdx);\n  }\n\n  // Get the last item (or the only item if no commas)\n  if (startIdx &lt; objectListString.length() &amp;&amp; count &lt; MAX_ITEMS) {\n    tempItems[count] = objectListString.substring(startIdx);\n    tempItems[count].trim();\n    count++;\n  }\n\n  if (count &gt; 0) {\n    storeObjectsInEEPROM(tempItems, count);\n    loadObjectsFromEEPROM(); // Reload to confirm storage worked\n  }\n}\n\nvoid setup() {\n  Serial.begin(9600);\n  while (!Serial);\n  delay(1000);\n\n  Serial.println(\"\ud83e\udd16 Arduino Object Sorter Starting...\");\n\n  // Try to load existing objects from EEPROM\n  loadObjectsFromEEPROM();\n\n  Serial.println(\"READY\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String input = Serial.readStringUntil('\\n');\n    input.trim();\n\n    if (input.startsWith(\"STORE_OBJECTS:\")) {\n      // Extract the object list from the command\n      String objectList = input.substring(14); // Remove \"STORE_OBJECTS:\" prefix\n      Serial.print(\"\ud83d\udcdd Storing objects: \");\n      Serial.println(objectList);\n      processObjectList(objectList);\n\n    } else if (input == \"LOAD_OBJECTS\") {\n      loadObjectsFromEEPROM();\n\n    } else if (input == \"LIST_OBJECTS\") {\n      if (itemsLoaded &amp;&amp; numStoredItems &gt; 0) {\n        Serial.println(\"\ud83d\udccb Current object list:\");\n        for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n          Serial.print(\"  \");\n          Serial.print(i + 1);\n          Serial.print(\": \");\n          Serial.println(storedItems[i]);\n        }\n      } else {\n        Serial.println(\"\ud83d\udced No objects stored\");\n      }\n\n    } else if (input == \"CLEAR_OBJECTS\") {\n      EEPROM.write(NUM_ITEMS_ADDR, 0);\n      numStoredItems = 0;\n      itemsLoaded = false;\n      Serial.println(\"\ud83d\uddd1\ufe0f Object list cleared\");\n\n    } else if (input == \"scan\") {\n      currentMode = \"scan\";\n      unsigned long currentTime = millis();\n      if (lastModeMessage != \"scan\" || (currentTime - lastModeTime) &gt; MODE_MESSAGE_COOLDOWN) {\n        Serial.println(\"\ud83d\udcf8 Scan mode active\");\n        lastModeMessage = \"scan\";\n        lastModeTime = currentTime;\n      }\n\n    } else if (input == \"sort\") {\n      currentMode = \"sort\";\n      unsigned long currentTime = millis();\n      if (itemsLoaded) {\n        if (lastModeMessage != \"sort\" || (currentTime - lastModeTime) &gt; MODE_MESSAGE_COOLDOWN) {\n          Serial.println(\"\u2699\ufe0f Sort mode active\");\n          lastModeMessage = \"sort\";\n          lastModeTime = currentTime;\n        }\n      } else {\n        Serial.println(\"\u274c Cannot sort - no objects loaded\");\n      }\n\n    } else if (input == \"stop\") {\n      currentMode = \"\";\n      Serial.println(\"\u23f9\ufe0f Stopped\");\n      lastModeMessage = \"\";  // Reset so next mode change shows message\n\n    } else if (currentMode == \"sort\" &amp;&amp; itemsLoaded) {\n      // This would be a detected object class from Python\n      handleSorting(input);\n\n    } else {\n      Serial.print(\"\u2753 Unknown command: \");\n      Serial.println(input);\n    }\n  }\n}\n</code></pre></p>"},{"location":"software_v1/#results","title":"Results","text":"<p>Image shown below, with appearance and some error handling shown:</p> <p></p>"},{"location":"software_v2/","title":"Version 2 (Minimum Viable Software Achieved)","text":""},{"location":"software_v2/#brief-intro-and-technical-details","title":"Brief Intro and Technical Details","text":"<p>Here is a quick overview of the software:</p> <ul> <li>Scanning Mode \u2192 Scans all objects that need to be sorted, with a list of unique objects stored in a .csv file.</li> <li>Sorting Mode \u2192 Sorts the objects in a binary fashion, which means that system looks for a target object in a set number of passes. Refer to video for demo of this.</li> </ul> <p>Here is a quick overview of the key features:</p> <ul> <li>Object Detection \u2192 Done by utilizing webcam and YOLO; users can select a PyTorch model to be used</li> <li>Object Logging \u2192 Stores list of unique objects in csv to be read by Arduino; objects also stored in Arduino's EEPROM in case system powers off</li> <li>User Control \u2192 User dictates when the software does what</li> <li>Arduino Recognition \u2192 Software knows when Arduino is connected and will not start scanning or sorting until then</li> <li>Arduino Echoing \u2192 Arduino send an echo of messages to log to provide updates to user, so that Serial Monitor doesn't have to be open</li> <li>Error Handling \u2192 More information below</li> </ul> <p>Error Handling:</p> <ul> <li>User must select PyTorch model to be able to enter sorting/scanning mode</li> <li>User must connect to an Arduino AND serial communication must be established to be able to enter sorting/scanning mode</li> <li>Sorting can only take place if a model has been selected and a list of objects has been sent</li> <li>etc...</li> </ul> <p>What is missing with this version?</p> <ul> <li>Motors \u2192 Motor selection not 100% finalized at this stage, values will be inputted once motors are finalized</li> </ul> <p>Note that software does not perform 100% perfectly. However, for the purposes of this project, it is enough to be able to proceed, as it performs basic functions up to a standard acceptable for a prototype. </p> <p>How does this compare to the requirements laid out on the milestones page?</p> Requirement from Milestone 3 Status Notes (if needed) Be intuitive to use, and look somewhat polished \u2705 Used customtkinter to achieve a more modern look; mostly polished appearance Allow user to perform basic functions \u2705 System can be used to detect and scan, with framework in place to sort Allow user control over the process \u2705 User dictates entire process, minus the actual object detection At the minimum, recognize when an Arduino is connected via USB to laptop \u2705 System can recognize AND communicate with Arduino Leverage webcam to detect objects \u2705 Utilizes YOLO and webcam to detect objects, with bounding boxes serving as visual confirmation Have some error handling in place and prevent user from going too far out of order \u2705 Error handling talked about above"},{"location":"software_v2/#code","title":"Code","text":"appv2.py<pre><code>import customtkinter as ctk\nfrom tkinter import filedialog, messagebox\nfrom customtkinter import CTkImage\n# import tkinter as tk\n# from tkinter import ttk, filedialog, messagebox\nfrom PIL import Image, ImageTk\nimport cv2\nfrom ultralytics import YOLO\nimport csv\nimport os\nimport serial\nimport threading\nfrom datetime import datetime\nimport serial.tools.list_ports\nimport time\nimport csv\nfrom PIL import ImageDraw, ImageFont\n\n# ---------------------------\n# \u2699\ufe0f CONFIGURATION\n# ---------------------------\nCAMERA_INDEX = 0\nWINDOW_TITLE = \"YOLO-Based Binary Object Sorting System V2\"\nWINDOW_BG_COLOR = \"#1e1e1e\"\nFRAME_RATE_MS = 15\nLOG_DIR = \"logs\"\n\n# ---------------------------\n# \ud83d\udcc1 Ensure Logs Folder Exists\n# ---------------------------\nos.makedirs(LOG_DIR, exist_ok=True)\n\ndef generate_csv_name():\n    now = datetime.now()\n    return f\"{LOG_DIR}/scan_log_{now.strftime('%Y-%m-%d_%H-%M-%S')}.csv\"\n\n# ---------------------------\n# Connection to Arduino\n# ---------------------------\n\ndef find_arduino_port():\n    ports = serial.tools.list_ports.comports()\n    for port in ports:\n        if \"Leonardo\" in port.description or (port.vid == 0x2341 and port.pid == 0x8036):\n            return port.device\n    return None\n\ndef reset_arduino_before_exit(port):\n    try:\n        ser = serial.Serial(port, 1200)\n        ser.close()\n        print(\"\ud83d\uded1 Arduino reset triggered\")\n        time.sleep(2)  # wait for Arduino to fully reset\n    except Exception as e:\n        print(f\"\u26a0\ufe0f Could not reset Arduino: {e}\")\n\ndef get_unique_classes_from_csv(path):\n    unique_classes = set()\n    try:\n        with open(path, newline='') as f:\n            reader = csv.reader(f)\n            for row in reader:\n                if len(row) &gt;= 2:\n                    unique_classes.add(row[1])\n    except Exception as e:\n        print(f\"Error reading CSV: {e}\")\n    return list(unique_classes)\n\ndef send_objects_to_eeprom(item_list, arduino_serial):\n    \"\"\"\n    Send object list to Arduino for EEPROM storage\n    Much simpler than SerialTransfer!\n    \"\"\"\n    try:\n        # Create comma-separated string\n        object_string = \",\".join(item_list[:20])  # Limit to 20 items\n\n        # Send the command\n        command = f\"STORE_OBJECTS:{object_string}\\n\"\n        arduino_serial.write(command.encode())\n\n        print(f\"\u2705 Sent {len(item_list)} objects to Arduino EEPROM\")\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Failed to send objects: {e}\")\n        return False\n\n# ---------------------------\n# \ud83d\uddbc GUI Class\n# ---------------------------\nclass YOLOApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(WINDOW_TITLE)\n        self.root.configure(bg_color=WINDOW_BG_COLOR)\n        self.arduino = None\n\n        self.cap = cv2.VideoCapture(CAMERA_INDEX)\n        if not self.cap.isOpened():\n            raise RuntimeError(\"\u274c Cannot open webcam\")\n\n        self.is_running = False\n        self.mode = None  # 'scan' or 'sort'\n        self.csv_file = None\n        self.detected_classes = set()\n        self.model_path = \"\"\n        self.model = None\n        self.arduino_ready_to_sort = False\n\n        # Binary Sorting Algorithm Variables\n        self.sort_classes = []  # List of classes to sort through\n        self.current_sort_index = 0  # Which class we're currently sorting\n        self.current_target_class = None  # The class we're looking for in this pass\n        self.sorting_in_progress = False  # Whether we're actively sorting\n        self.waiting_for_next_pass = False  # Whether we're waiting for user to start next pass\n\n        # Layout frames\n        main_frame = ctk.CTkFrame(root, bg_color=WINDOW_BG_COLOR)\n        main_frame.pack(fill=ctk.BOTH, expand=True)\n\n        left_frame = ctk.CTkFrame(main_frame, bg_color=WINDOW_BG_COLOR)\n        left_frame.pack(side=ctk.LEFT, padx=10, pady=10)\n\n        right_frame = ctk.CTkFrame(main_frame, bg_color=WINDOW_BG_COLOR)\n        right_frame.pack(side=ctk.RIGHT, padx=10, pady=10, fill=ctk.BOTH, expand=True)\n\n        # Video Frame\n        self.video_frame = ctk.CTkLabel(left_frame)\n        self.video_frame.pack()\n\n        # Create a black placeholder with text \"Camera Offline\"\n        placeholder = Image.new(\"RGB\", (640, 480), (0, 0, 0))\n        draw = ImageDraw.Draw(placeholder)\n\n        try:\n            font = ImageFont.truetype(\"arial.ttf\", 36)\n        except:\n            font = ImageFont.load_default()\n\n        text = \"CAMERA OFFLINE\"\n        bbox = draw.textbbox((0, 0), text, font=font)\n        text_width = bbox[2] - bbox[0]\n        text_height = bbox[3] - bbox[1]\n        position = ((640 - text_width) // 2, (480 - text_height) // 2)\n        draw.text(position, text, fill=(200, 200, 200), font=font)\n\n        self.placeholder_img = CTkImage(light_image=placeholder, dark_image=placeholder, size=(640, 480))\n        self.video_frame.configure(image=self.placeholder_img, text=\"\")  # text=\"\" prevents text overlay\n        self.video_frame.imgtk = self.placeholder_img  # Keep a reference\n\n        # Control Buttons\n        btn_frame = ctk.CTkFrame(left_frame, bg_color=WINDOW_BG_COLOR)\n        btn_frame.pack(pady=10)\n\n        self.choose_model_btn = ctk.CTkButton(btn_frame, text=\"Choose PyTorch Model\", command=self.choose_model)\n        self.choose_model_btn.grid(row=0, column=0, padx=5)\n\n        self.arduino_btn = ctk.CTkButton(btn_frame, text=\"Connect to Arduino\", command=self.connect_to_arduino)\n        self.arduino_btn.grid(row=0, column=1, padx=5)\n\n        self.scan_btn = ctk.CTkButton(btn_frame, text=\"\ud83d\udcf8 Start Scanning Mode\", command=self.start_scanning_mode)\n        self.scan_btn.grid(row=0, column=2, padx=5)\n\n        self.sort_btn = ctk.CTkButton(btn_frame, text=\"\u2699\ufe0f Start Sorting Mode\", command=self.start_sorting_mode)\n        self.sort_btn.grid(row=0, column=3, padx=5)\n\n        self.stop_btn = ctk.CTkButton(btn_frame, text=\"\u23f9 Stop\", command=self.stop_detection)\n        self.stop_btn.grid(row=0, column=4, padx=5)\n\n        # Second row of buttons - MERGED FUNCTIONALITY\n        self.list_objects_btn = ctk.CTkButton(btn_frame, text=\"\ud83d\udccb List Stored Objects\", command=self.list_stored_objects)\n        self.list_objects_btn.grid(row=1, column=0, padx=5)\n\n        self.clear_objects_btn = ctk.CTkButton(btn_frame, text=\"\ud83d\uddd1\ufe0f Clear Objects\", command=self.clear_stored_objects)\n        self.clear_objects_btn.grid(row=1, column=1, padx=5)\n\n        # NEW: Merged sorting button that handles everything\n        self.start_sorting_session_btn = ctk.CTkButton(btn_frame, text=\"\ud83d\ude80 Start Sorting Session\", \n                                                   command=self.start_sorting_session)\n        self.start_sorting_session_btn.grid(row=1, column=2, columnspan=2, pady=10, padx=5)\n\n        exit_button = ctk.CTkButton(btn_frame, text=\"Exit\", command=self.exit_app)\n        exit_button.grid(row=1, column=4, padx=5)\n\n        # Third row - Binary Sorting Controls (simplified)\n        sort_control_frame = ctk.CTkFrame(btn_frame, bg_color=WINDOW_BG_COLOR)\n        sort_control_frame.grid(row=2, column=0, columnspan=5, pady=10)\n\n        self.next_pass_btn = ctk.CTkButton(sort_control_frame, text=\"\u27a1\ufe0f Next Pass\", command=self.start_next_pass, state=ctk.DISABLED)\n        self.next_pass_btn.grid(row=0, column=0, padx=5)\n\n        self.finish_sort_btn = ctk.CTkButton(sort_control_frame, text=\"\u2705 Finish Sorting\", command=self.finish_sorting, state=ctk.DISABLED)\n        self.finish_sort_btn.grid(row=0, column=1, padx=5)\n\n        # Sorting Status Display\n        self.sort_status_label = ctk.CTkLabel(\n            sort_control_frame,\n            text=\"Arduino not connected\",\n            text_color=\"red\",\n            fg_color=\"transparent\",\n            bg_color=WINDOW_BG_COLOR,\n            font=(\"Segoe UI\", 10, \"bold\")\n        )\n        self.sort_status_label.grid(row=1, column=0, columnspan=2, pady=5)\n\n        # Output Log\n        self.log_text = ctk.CTkTextbox(\n            right_frame,\n            width=400,         # Increased width\n            height=300,        # Increased height\n            fg_color=\"black\",  # Background color\n            text_color=\"white\",# Fix white-on-white issue\n            wrap=\"word\"\n        )       \n        self.log_text.pack(fill=ctk.BOTH, expand=True, padx=5, pady=5)\n        self.log(\"\ud83d\udfe2 GUI Initialized\")\n\n        # ---------------------------\n        # \ud83c\udfa8 Button Styling\n        # ---------------------------\n        # style = ttk.Style()\n        # style.theme_use(\"default\")\n        # style.configure(\"TButton\", background=\"#444\", foreground=\"white\", padding=6, font=(\"Segoe UI\", 10, \"bold\"))\n        # style.map(\"TButton\", background=[(\"active\", \"#777\")])\n\n    # ---------------------------\n    # \ud83e\uddfe Log Output\n    # ---------------------------\n    def log(self, message):\n        timestamp = datetime.now().strftime(\"[%H:%M:%S]\")\n        self.log_text.insert(ctk.END, f\"{timestamp} {message}\\n\")\n        self.log_text.see(ctk.END)\n\n    # ---------------------------\n    # \ud83d\ude80 NEW: Merged Sorting Session Function\n    # ---------------------------\n    def start_sorting_session(self):\n        \"\"\"\n        Merged function that handles:\n        1. Model validation\n        2. File selection (single dialog)\n        3. Sending objects to Arduino\n        4. Setting up binary sort\n        5. Starting camera/sorting mode\n        \"\"\"\n        # Validation checks\n        if self.model is None:\n            self.log(\"\u274c No model selected. Please choose a PyTorch model first.\")\n            messagebox.showerror(\"Error\", \"Please select a PyTorch model before starting sorting session.\")\n            return\n\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u274c Arduino not connected. Please connect Arduino first.\")\n            messagebox.showerror(\"Error\", \"Please connect Arduino before starting sorting session.\")\n            return\n\n        # Single file dialog for CSV with detected objects\n        filepath = filedialog.askopenfilename(\n            title=\"Select CSV with detected objects for sorting\",\n            filetypes=[(\"CSV Files\", \"*.csv\")]\n        )\n        if not filepath:\n            self.log(\"\u26a0\ufe0f No file selected - sorting session cancelled\")\n            return\n\n        classes = get_unique_classes_from_csv(filepath)\n        if not classes:\n            self.log(\"\u26a0\ufe0f No valid classes found in CSV\")\n            messagebox.showerror(\"Error\", \"No valid object classes found in the selected CSV file.\")\n            return\n\n        self.log(f\"\ud83d\udcc2 Processing file: {os.path.basename(filepath)}\")\n        self.log(f\"\ud83d\udcca Found {len(classes)} unique classes: {', '.join(classes)}\")\n\n        # Send objects to Arduino EEPROM\n        self.log(f\"\ud83d\udce4 Sending {len(classes)} objects to Arduino EEPROM...\")\n        if not send_objects_to_eeprom(classes, self.arduino):\n            self.log(\"\u274c Failed to send objects to Arduino\")\n            messagebox.showerror(\"Error\", \"Failed to send object list to Arduino.\")\n            return\n\n        self.log(f\"\u2705 Successfully sent objects to Arduino\")\n\n        # Wait for Arduino to confirm it's ready\n        self.log(\"\u23f3 Waiting for Arduino to process objects...\")\n\n        # Setup binary sorting\n        self.sort_classes = classes\n        self.current_sort_index = 0\n        self.current_target_class = self.sort_classes[0] if self.sort_classes else None\n        self.sorting_in_progress = False\n        self.waiting_for_next_pass = False\n        self.arduino_ready_to_sort = True\n\n        self.log(f\"\ud83c\udfaf Binary sort setup complete!\")\n        self.log(f\"\ud83d\udd04 Total passes needed: {len(self.sort_classes)}\")\n\n        # Enable sorting controls\n        self.update_sort_status()\n        self.next_pass_btn.configure(state=ctk.NORMAL)\n        self.finish_sort_btn.configure(state=ctk.NORMAL)\n\n        # Start sorting mode automatically\n        self.start_sorting_mode()\n\n        self.log(\"\ud83d\ude80 Sorting session ready! Click 'Next Pass' to begin first sorting pass.\")\n\n    # ---------------------------\n    # \ud83c\udfaf Binary Sorting Functions (simplified)\n    # ---------------------------\n    def update_sort_status(self):\n        if not self.arduino_ready_to_sort:\n            self.sort_status_label.configure(text=\"\u274c Arduino not ready\", text_color=\"red\")\n            return\n\n        if not self.sort_classes:\n            self.sort_status_label.configure(text=\"\u2705 Ready to start sorting session\", text_color=\"green\")\n            return\n\n        if self.current_sort_index &gt;= len(self.sort_classes):\n            self.sort_status_label.configure(text=\"\ud83c\udf89 All sorting passes complete!\", text_color=\"green\")\n            return\n\n        # Status for in-progress session\n        status = f\"Pass {self.current_sort_index + 1}/{len(self.sort_classes)} - Target: '{self.current_target_class}'\"\n        if self.sorting_in_progress:\n            status += \" (ACTIVE)\"\n        elif self.waiting_for_next_pass:\n            status += \" (WAITING)\"\n        else:\n            status += \" (READY)\"\n\n        self.sort_status_label.configure(text=status, text_color=\"white\")\n\n    def start_next_pass(self):\n        if not self.sort_classes or self.current_sort_index &gt;= len(self.sort_classes):\n            self.log(\"\u2705 All sorting passes completed!\")\n            self.finish_sorting()\n            return\n\n        self.current_target_class = self.sort_classes[self.current_sort_index]\n        self.sorting_in_progress = True\n        self.waiting_for_next_pass = False\n\n        self.log(f\"\u25b6\ufe0f Starting Pass {self.current_sort_index + 1}: Sorting '{self.current_target_class}'\")\n        self.log(f\"\ud83d\udcdd Instructions: '{self.current_target_class}' \u2192 Target pile, All others \u2192 Other pile\")\n\n        # Send the target class to Arduino\n        self.send_to_arduino(f\"SET_TARGET:{self.current_target_class}\")\n\n        self.update_sort_status()\n        self.next_pass_btn.configure(text=\"\u23f8\ufe0f Pause Pass\", command=self.pause_current_pass)\n\n    def pause_current_pass(self):\n        if self.sorting_in_progress:\n            self.sorting_in_progress = False\n            self.waiting_for_next_pass = True\n            self.current_sort_index += 1\n\n            self.log(f\"\u23f8\ufe0f Pass paused. Ready for next pass.\")\n\n            if self.current_sort_index &lt; len(self.sort_classes):\n                self.log(f\"\ud83d\udccb Next pass will sort: '{self.sort_classes[self.current_sort_index]}'\")\n                self.next_pass_btn.configure(text=\"\u27a1\ufe0f Next Pass\", command=self.start_next_pass)\n            else:\n                self.log(\"\ud83c\udf89 All passes completed!\")\n                self.next_pass_btn.configure(state=ctk.DISABLED)\n\n            self.update_sort_status()\n            self.send_to_arduino(\"PAUSE_SORT\")\n\n    def finish_sorting(self):\n        self.sorting_in_progress = False\n        self.waiting_for_next_pass = False\n        self.current_sort_index = 0\n        self.sort_classes = []\n        self.current_target_class = None\n\n        self.log(\"\u2705 Sorting session finished\")\n        self.update_sort_status()\n\n        self.next_pass_btn.configure(text=\"\u27a1\ufe0f Next Pass\", command=self.start_next_pass, state=ctk.DISABLED)\n        self.finish_sort_btn.configure(state=ctk.DISABLED)\n\n        self.send_to_arduino(\"FINISH_SORT\")\n\n    # ---------------------------\n    # \ud83d\udea6 MODE SWITCHING\n    # ---------------------------\n    def start_scanning_mode(self):\n        if self.mode == \"scan\":\n            self.stop_detection()\n            return\n\n        if self.model is None:\n            self.log(\"\u26a0\ufe0f No model selected\")\n            return\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n            return\n\n        self.stop_detection()\n        self.mode = \"scan\"\n        self.scan_btn.configure(text=\"\u23f9 Stop Scanning Mode\", state=ctk.NORMAL)\n        self.sort_btn.configure(state=ctk.DISABLED)\n        self.csv_file = generate_csv_name()\n        self.detected_classes.clear()\n        self.log(f\"\ud83d\udcc4 Logging to: {self.csv_file}\")\n        self.is_running = True\n        self.update_frame()\n\n    def start_sorting_mode(self):\n        if self.mode == \"sort\":\n            self.stop_detection()\n            return\n        if self.model is None:\n            self.log(\"\u26a0\ufe0f No model selected\")\n            return\n        if self.arduino is None or not self.arduino.is_open:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n            return\n        if not self.arduino_ready_to_sort:\n            self.log(\"\u274c Arduino is not ready. Start sorting session first.\")\n            return\n        if not self.sort_classes:\n            self.log(\"\u274c No sorting session active. Use 'Start Sorting Session' first!\")\n            return\n\n        self.stop_detection()\n        self.mode = \"sort\"\n        self.sort_btn.configure(text=\"\u23f9 Stop Sorting Mode\", state=ctk.NORMAL)\n        self.scan_btn.configure(state=ctk.DISABLED)\n        self.log(\"\u2699\ufe0f Sorting mode active\")\n        self.is_running = True\n        self.update_frame()\n\n    def stop_detection(self):\n        self.is_running = False\n        was_sorting = (self.mode == \"sort\")\n        self.mode = None\n        self.video_frame.configure(image=self.placeholder_img)\n        self.video_frame.imgtk = self.placeholder_img\n        self.scan_btn.configure(text=\"\ud83d\udcf8 Start Scanning Mode\", state=ctk.NORMAL)\n        self.sort_btn.configure(text=\"\u2699\ufe0f Start Sorting Mode\", state=ctk.NORMAL)\n\n        # Send stop command to Arduino\n        self.send_to_arduino(\"stop\")\n\n        if was_sorting:\n            self.log(\"\ud83d\uded1 Detection stopped - Sorting mode disabled\")\n        else:\n            self.log(\"\ud83d\uded1 Detection stopped\")\n\n    def choose_model(self):\n        if self.is_running:\n            self.log(\"\u26a0\ufe0f Stop detection before loading a new model\")\n            return\n        path = filedialog.askopenfilename(filetypes=[(\"PyTorch Model\", \"*.pt\")])\n        if path:\n            self.model_path = path\n            self.model = YOLO(self.model_path)\n            self.log(f\"\u2705 Model loaded: {self.model_path}\")\n\n    # ---------------------------\n    # \ud83d\udd01 Frame Processing\n    # ---------------------------\n    def update_frame(self):\n        if not self.is_running:\n            return\n\n        ret, frame = self.cap.read()\n        if not ret:\n            self.log(\"\u274c Failed to grab frame - stopping detection\")\n            self.stop_detection()\n            return\n\n        results = self.model(frame)[0]\n        annotated = results.plot()\n\n        if self.mode == \"scan\":\n            self.handle_scanning_mode(results)\n        elif self.mode == \"sort\":\n            self.handle_sorting_mode(results)\n\n        rgb_frame = cv2.cvtColor(annotated, cv2.COLOR_BGR2RGB)\n        img = Image.fromarray(rgb_frame)\n        img_size = img.size  # This returns (width, height)\n        ctk_img = CTkImage(light_image=img, dark_image=img, size=img_size)  # dynamic size\n        self.video_frame.imgtk = ctk_img\n        self.video_frame.configure(image=ctk_img, text=\"\")\n\n        self.root.after(FRAME_RATE_MS, self.update_frame)\n\n    # ---------------------------\n    # \ud83d\udcf8 Scanning Mode Logic\n    # ---------------------------\n    def handle_scanning_mode(self, results):\n        self.send_to_arduino(\"scan\")\n        for box in results.boxes:\n            cls_id = int(box.cls[0])\n            class_name = self.model.names[cls_id]\n            if class_name not in self.detected_classes:\n                self.detected_classes.add(class_name)\n                with open(self.csv_file, 'a', newline='') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([datetime.now().isoformat(), class_name])\n                self.log(f\"\ud83d\udcdd Logged: {class_name}\")\n\n    # ---------------------------\n    # \u2699\ufe0f Enhanced Sorting Mode Logic\n    # ---------------------------\n    def handle_sorting_mode(self, results):\n        if not self.sorting_in_progress or not self.current_target_class:\n            return\n\n        self.send_to_arduino(\"sort\")\n\n        # Process all detected objects\n        for box in results.boxes:\n            cls_id = int(box.cls[0])\n            class_name = self.model.names[cls_id]\n\n            if class_name == self.current_target_class:\n                self.log(f\"\ud83c\udfaf TARGET FOUND: {class_name} \u2192 Target pile\")\n                self.send_to_arduino(f\"SORT_TARGET:{class_name}\")\n            else:\n                self.log(f\"\ud83d\udce6 OTHER: {class_name} \u2192 Other pile\")\n                self.send_to_arduino(f\"SORT_OTHER:{class_name}\")\n\n            # Only process the first detection to avoid spam\n            break\n\n    # ---------------------------\n    # \ud83d\udd0c Arduino Communication\n    # ---------------------------\n\n    def connect_to_arduino(self):\n        port = find_arduino_port()\n        self.update_sort_status()\n        if port:\n            try:\n                self.arduino = serial.Serial(port, 9600, timeout=2)\n                self.log(f\"\ud83d\udfe1 Connecting to Arduino on {port}...\")\n\n                time.sleep(2)  # Allow time for Arduino to reset and send handshake\n\n                # Wait for \"READY\"\n                start_time = time.time()\n                ready_line = \"\"\n                while time.time() - start_time &lt; 5:\n                    if self.arduino.in_waiting &gt; 0:\n                        ready_line = self.arduino.readline().decode().strip()\n                        if ready_line == \"READY\":\n                            break\n                        elif ready_line:  # Any other message from Arduino\n                            self.log(f\"Arduino: {ready_line}\")\n\n                if ready_line == \"READY\":\n                    self.log(\"\u2705 Arduino is ready!\")\n                    self.arduino_btn.configure(text=\"Arduino Connected!\", state=ctk.DISABLED)\n\n                    # Start listening thread for Arduino messages\n                    self.start_arduino_listener()\n                else:\n                    self.log(f\"\u274c Unexpected handshake message: {ready_line}\")\n            except serial.SerialException as e:\n                self.log(f\"\u274c Connection Failed: {str(e)}\")\n        else:\n            self.log(\"\u26a0\ufe0f No Arduino found!\")\n\n    def start_arduino_listener(self):\n        \"\"\"Start a background thread to listen for Arduino messages\"\"\"\n        def listen():\n            while self.arduino and self.arduino.is_open:\n                try:\n                    if self.arduino.in_waiting &gt; 0:\n                        message = self.arduino.readline().decode().strip()\n                        if message:\n                            if message == \"READY_TO_SORT\":\n                                self.arduino_ready_to_sort = True\n                                self.log(\"\ud83d\udfe2 Arduino ready to sort!\")\n                            else:\n                                self.log(f\"Arduino: {message}\")\n                    time.sleep(0.1)\n                except Exception as e:\n                    if self.arduino and self.arduino.is_open:\n                        self.log(f\"Error reading from Arduino: {e}\")\n                    break\n\n        listener_thread = threading.Thread(target=listen, daemon=True)\n        listener_thread.start()\n\n    def send_to_arduino(self, message):\n        try:\n            if self.arduino and self.arduino.is_open:\n                self.arduino.write((message + \"\\n\").encode())\n        except Exception as e:\n            self.log(f\"\u274c Error sending to Arduino: {e}\")\n\n    def list_stored_objects(self):\n        \"\"\"Ask Arduino to list stored objects\"\"\"\n        if self.arduino and self.arduino.is_open:\n            self.send_to_arduino(\"LIST_OBJECTS\")\n        else:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n\n    def clear_stored_objects(self):\n        \"\"\"Clear objects from Arduino EEPROM\"\"\"\n        if self.arduino and self.arduino.is_open:\n            self.send_to_arduino(\"CLEAR_OBJECTS\")\n            self.arduino_ready_to_sort = False\n            self.log(\"\ud83d\uddd1\ufe0f Cleared stored objects\")\n        else:\n            self.log(\"\u26a0\ufe0f Arduino not connected\")\n        self.update_sort_status()\n\n    def exit_app(self):\n        if self.arduino and self.arduino.is_open:\n            port = self.arduino.port\n            self.arduino.close()\n            self.clear_stored_objects()\n            reset_arduino_before_exit(port)\n        self.root.destroy()\n\n# ---------------------------\n# \ud83d\ude80 Run GUI\n# ---------------------------\nif __name__ == \"__main__\":\n    root = ctk.CTk()\n    app = YOLOApp(root)\n    root.mainloop()\n\n    if app.cap.isOpened():\n        app.cap.release()\n    cv2.destroyAllWindows()\n</code></pre> arduino_v2.ino<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;EEPROM.h&gt;\n\n// ===== MOTOR CONTROL INCLUDES =====\n// TODO: Add your servo/stepper motor library includes here\n// Example: #include &lt;Servo.h&gt;\n// Example: #include &lt;Stepper.h&gt;\n\n// ===== MOTOR CONTROL OBJECTS =====\n// TODO: Initialize your motor control objects here\n// Example: Servo sortingServo;\n// Example: Stepper conveyorMotor(stepsPerRevolution, motorPin1, motorPin2, motorPin3, motorPin4);\n\n// ===== MOTOR CONTROL PINS =====\n// TODO: Define your motor control pins here\n// Example: const int SERVO_PIN = 9;\n// Example: const int CONVEYOR_ENABLE_PIN = 8;\n// Example: const int CONVEYOR_DIR_PIN = 7;\n// Example: const int CONVEYOR_STEP_PIN = 6;\n\n// Storage constants\nconst uint8_t MAX_ITEMS = 30;\nconst uint8_t MAX_STR_LEN = 50;\nconst int EEPROM_START_ADDR = 0;\nconst int NUM_ITEMS_ADDR = 0;\nconst int ITEMS_START_ADDR = 1;\n\n// Object storage\nString storedItems[MAX_ITEMS];\nuint8_t numStoredItems = 0;\n\n// Mode tracking\nString currentMode = \"\";\nString lastModeMessage = \"\";\nunsigned long lastModeTime = 0;\nconst unsigned long MODE_MESSAGE_COOLDOWN = 5000; // 5 seconds between mode messages\nbool itemsLoaded = false;\n\n// Binary Sorting Variables\nString currentTargetClass = \"\";\nbool binarySortActive = false;\nString lastSortedItem = \"\";\nunsigned long lastSortTime = 0;\nconst unsigned long SORT_COOLDOWN = 2000; // 2 seconds between same item sorts\n\n// ===== MOTOR CONTROL POSITIONS =====\n// TODO: Define your sorting positions/angles here\n// Example: const int TARGET_POSITION = 90;    // Servo angle for target pile\n// Example: const int OTHER_POSITION = -90;    // Servo angle for other pile\n// Example: const int CENTER_POSITION = 0;     // Servo center/neutral position\n// Example: const int CONVEYOR_SPEED = 100;    // Conveyor belt speed\n\n// ===== FUNCTION DECLARATIONS =====\nvoid performTargetSortAction();\nvoid performOtherSortAction();\nvoid handleBinarySortTarget(String itemClass);\nvoid handleBinarySortOther(String itemClass);\nvoid processObjectList(String objectListString);\nvoid storeObjectsInEEPROM(String objects[], uint8_t count);\nvoid loadObjectsFromEEPROM();\n\nvoid storeObjectsInEEPROM(String objects[], uint8_t count) {\n  // Store number of items first\n  EEPROM.write(NUM_ITEMS_ADDR, count);\n\n  int addr = ITEMS_START_ADDR;\n  for (uint8_t i = 0; i &lt; count; i++) {\n    String item = objects[i];\n\n    // Store length of string\n    uint8_t len = min(item.length(), (unsigned int)(MAX_STR_LEN - 1));\n    EEPROM.write(addr, len);\n    addr++;\n\n    // Store the string characters\n    for (uint8_t j = 0; j &lt; len; j++) {\n      EEPROM.write(addr, item[j]);\n      addr++;\n    }\n\n    // Fill remaining space with zeros\n    for (uint8_t j = len; j &lt; MAX_STR_LEN - 1; j++) {\n      EEPROM.write(addr, 0);\n      addr++;\n    }\n  }\n\n  Serial.println(\"\u2705 Objects stored in EEPROM\");\n}\n\nvoid loadObjectsFromEEPROM() {\n  numStoredItems = EEPROM.read(NUM_ITEMS_ADDR);\n\n  // Sanity check\n  if (numStoredItems &gt; MAX_ITEMS) {\n    numStoredItems = 0;\n    Serial.println(\"\u26a0\ufe0f Invalid EEPROM data, resetting\");\n    return;\n  }\n\n  if (numStoredItems == 0) {\n    Serial.println(\"\ud83d\udced No objects stored in EEPROM\");\n    return;\n  }\n\n  int addr = ITEMS_START_ADDR;\n  for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n    uint8_t len = EEPROM.read(addr);\n    addr++;\n\n    if (len &gt;= MAX_STR_LEN) len = 0; // Corrupted data\n\n    String item = \"\";\n    for (uint8_t j = 0; j &lt; len; j++) {\n      char c = EEPROM.read(addr);\n      if (c != 0) item += c;\n      addr++;\n    }\n\n    // Skip remaining bytes for this item\n    addr += (MAX_STR_LEN - 1 - len);\n    storedItems[i] = item;\n  }\n\n  if (numStoredItems &gt; 0) {\n    itemsLoaded = true;\n    Serial.println(\"\ud83d\udce5 Objects loaded from EEPROM:\");\n    for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n      Serial.print(\" \");\n      Serial.println(storedItems[i]);\n    }\n    Serial.println(\"READY_TO_SORT\");\n  }\n}\n\nvoid handleBinarySortTarget(String itemClass) {\n  unsigned long currentTime = millis();\n\n  // Only process if it's a different item or enough time has passed\n  if (itemClass != lastSortedItem || (currentTime - lastSortTime) &gt; SORT_COOLDOWN) {\n    Serial.print(\"\ud83c\udfaf TARGET SORT: \");\n    Serial.println(itemClass);\n\n    // Perform target sorting action\n    performTargetSortAction();\n\n    lastSortedItem = itemClass;\n    lastSortTime = currentTime;\n  }\n}\n\nvoid handleBinarySortOther(String itemClass) {\n  unsigned long currentTime = millis();\n\n  // Only process if it's a different item or enough time has passed  \n  if (itemClass != lastSortedItem || (currentTime - lastSortTime) &gt; SORT_COOLDOWN) {\n    Serial.print(\"\ud83d\udce6 OTHER SORT: \");\n    Serial.println(itemClass);\n\n    // Perform other sorting action\n    performOtherSortAction();\n\n    lastSortedItem = itemClass;\n    lastSortTime = currentTime;\n  }\n}\n\nvoid performTargetSortAction() {\n  // ===== TARGET PILE MOTOR CONTROL =====\n  // TODO: Add your motor control code here for moving items to target pile\n\n  Serial.println(\"\u2192 Moving to TARGET pile\");\n\n  // Example servo control:\n  // sortingServo.write(TARGET_POSITION);  // Move to target pile position\n  // delay(1000);                          // Wait for movement\n  // sortingServo.write(CENTER_POSITION);  // Return to center\n\n  // Example stepper motor control:\n  // digitalWrite(CONVEYOR_DIR_PIN, HIGH); // Set direction to target pile\n  // for(int i = 0; i &lt; STEPS_TO_TARGET; i++) {\n  //   digitalWrite(CONVEYOR_STEP_PIN, HIGH);\n  //   delayMicroseconds(STEP_DELAY);\n  //   digitalWrite(CONVEYOR_STEP_PIN, LOW);\n  //   delayMicroseconds(STEP_DELAY);\n  // }\n\n  // Example pneumatic actuator control:\n  // digitalWrite(PNEUMATIC_TARGET_PIN, HIGH);  // Activate target actuator\n  // delay(500);                                // Hold position\n  // digitalWrite(PNEUMATIC_TARGET_PIN, LOW);   // Release\n\n  // TODO: Add any additional mechanical actions needed for target sorting\n  // Examples: conveyor belt control, pusher mechanisms, etc.\n}\n\nvoid performOtherSortAction() {\n  // ===== OTHER PILE MOTOR CONTROL =====\n  // TODO: Add your motor control code here for moving items to other pile\n\n  Serial.println(\"\u2192 Moving to OTHER pile\");\n\n  // Example servo control:\n  // sortingServo.write(OTHER_POSITION);   // Move to other pile position  \n  // delay(1000);                          // Wait for movement\n  // sortingServo.write(CENTER_POSITION);  // Return to center\n\n  // Example stepper motor control:\n  // digitalWrite(CONVEYOR_DIR_PIN, LOW);  // Set direction to other pile\n  // for(int i = 0; i &lt; STEPS_TO_OTHER; i++) {\n  //   digitalWrite(CONVEYOR_STEP_PIN, HIGH);\n  //   delayMicroseconds(STEP_DELAY);\n  //   digitalWrite(CONVEYOR_STEP_PIN, LOW);\n  //   delayMicroseconds(STEP_DELAY);\n  // }\n\n  // Example pneumatic actuator control:\n  // digitalWrite(PNEUMATIC_OTHER_PIN, HIGH);   // Activate other actuator\n  // delay(500);                                // Hold position\n  // digitalWrite(PNEUMATIC_OTHER_PIN, LOW);    // Release\n\n  // TODO: Add any additional mechanical actions needed for other sorting\n  // Examples: conveyor belt control, pusher mechanisms, etc.\n}\n\nvoid processObjectList(String objectListString) {\n  // Parse comma-separated string\n  String tempItems[MAX_ITEMS];\n  uint8_t count = 0;\n\n  int startIdx = 0;\n  int commaIdx = objectListString.indexOf(',');\n\n  while (commaIdx != -1 &amp;&amp; count &lt; MAX_ITEMS) {\n    tempItems[count] = objectListString.substring(startIdx, commaIdx);\n    tempItems[count].trim();\n    count++;\n    startIdx = commaIdx + 1;\n    commaIdx = objectListString.indexOf(',', startIdx);\n  }\n\n  // Get the last item (or the only item if no commas)\n  if (startIdx &lt; objectListString.length() &amp;&amp; count &lt; MAX_ITEMS) {\n    tempItems[count] = objectListString.substring(startIdx);\n    tempItems[count].trim();\n    count++;\n  }\n\n  if (count &gt; 0) {\n    storeObjectsInEEPROM(tempItems, count);\n    loadObjectsFromEEPROM(); // Reload to confirm storage worked\n  }\n}\n\nvoid setup() {\n  Serial.begin(9600);\n  while (!Serial);\n  delay(1000);\n\n  Serial.println(\"\ud83e\udd16 Arduino Binary Object Sorter Starting...\");\n\n  // ===== MOTOR CONTROL INITIALIZATION =====\n  // TODO: Initialize your motors and actuators here\n\n  // Example servo initialization:\n  // sortingServo.attach(SERVO_PIN);\n  // sortingServo.write(CENTER_POSITION);  // Start at center position\n\n  // Example stepper motor initialization:\n  // pinMode(CONVEYOR_ENABLE_PIN, OUTPUT);\n  // pinMode(CONVEYOR_DIR_PIN, OUTPUT);\n  // pinMode(CONVEYOR_STEP_PIN, OUTPUT);\n  // digitalWrite(CONVEYOR_ENABLE_PIN, HIGH);  // Enable stepper driver\n\n  // Example pneumatic initialization:\n  // pinMode(PNEUMATIC_TARGET_PIN, OUTPUT);\n  // pinMode(PNEUMATIC_OTHER_PIN, OUTPUT);\n  // digitalWrite(PNEUMATIC_TARGET_PIN, LOW);  // Ensure actuators start retracted\n  // digitalWrite(PNEUMATIC_OTHER_PIN, LOW);\n\n  // TODO: Add any sensor initialization here\n  // Example: proximity sensors, limit switches, etc.\n\n  // Try to load existing objects from EEPROM\n  loadObjectsFromEEPROM();\n\n  Serial.println(\"READY\");\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    String input = Serial.readStringUntil('\\n');\n    input.trim();\n\n    if (input.startsWith(\"STORE_OBJECTS:\")) {\n      // Extract the object list from the command\n      String objectList = input.substring(14); // Remove \"STORE_OBJECTS:\" prefix\n      Serial.print(\"\ud83d\udcdd Storing objects: \");\n      Serial.println(objectList);\n      processObjectList(objectList);\n\n    } else if (input.startsWith(\"SET_TARGET:\")) {\n      // Set the target class for binary sorting\n      currentTargetClass = input.substring(11); // Remove \"SET_TARGET:\" prefix\n      binarySortActive = true;\n      Serial.print(\"\ud83c\udfaf Target class set to: \");\n      Serial.println(currentTargetClass);\n      Serial.println(\"\ud83d\udd04 Binary sort mode activated\");\n\n      // ===== MOTOR CONTROL: SORTING SESSION START =====\n      // TODO: Add any initialization needed when starting a new sorting session\n      // Examples: move servos to ready position, start conveyor belt, etc.\n\n    } else if (input.startsWith(\"SORT_TARGET:\")) {\n      // Handle target object detection\n      if (binarySortActive) {\n        String detectedClass = input.substring(12); // Remove \"SORT_TARGET:\" prefix\n        handleBinarySortTarget(detectedClass);\n      }\n\n    } else if (input.startsWith(\"SORT_OTHER:\")) {\n      // Handle non-target object detection  \n      if (binarySortActive) {\n        String detectedClass = input.substring(11); // Remove \"SORT_OTHER:\" prefix\n        handleBinarySortOther(detectedClass);\n      }\n\n    } else if (input == \"PAUSE_SORT\") {\n      Serial.println(\"\u23f8\ufe0f Sorting pass paused\");\n\n      // ===== MOTOR CONTROL: PAUSE ACTIONS =====\n      // TODO: Add pause actions here\n      // Examples: stop conveyor belt, move servos to safe position, etc.\n\n      currentTargetClass = \"\";\n      lastSortedItem = \"\"; // Reset to allow immediate sorting when resumed\n\n    } else if (input == \"FINISH_SORT\") {\n      binarySortActive = false;\n      currentTargetClass = \"\";\n      lastSortedItem = \"\";\n      Serial.println(\"\u2705 Binary sorting session finished\");\n\n      // ===== MOTOR CONTROL: SESSION END =====\n      // TODO: Add cleanup actions here\n      // Examples: return all servos to home position, stop conveyor, etc.\n\n    } else if (input == \"LOAD_OBJECTS\") {\n      loadObjectsFromEEPROM();\n\n    } else if (input == \"LIST_OBJECTS\") {\n      if (itemsLoaded &amp;&amp; numStoredItems &gt; 0) {\n        Serial.println(\"\ud83d\udccb Current object list:\");\n        for (uint8_t i = 0; i &lt; numStoredItems; i++) {\n          Serial.print(\" \");\n          Serial.print(i + 1);\n          Serial.print(\": \");\n          Serial.println(storedItems[i]);\n        }\n        if (binarySortActive) {\n          Serial.print(\"\ud83c\udfaf Current target: \");\n          Serial.println(currentTargetClass);\n        }\n      } else {\n        Serial.println(\"\ud83d\udced No objects stored\");\n      }\n\n    } else if (input == \"CLEAR_OBJECTS\") {\n      EEPROM.write(NUM_ITEMS_ADDR, 0);\n      numStoredItems = 0;\n      itemsLoaded = false;\n      binarySortActive = false;\n      currentTargetClass = \"\";\n      Serial.println(\"\ud83d\uddd1\ufe0f Object list cleared\");\n\n    } else if (input == \"scan\") {\n      currentMode = \"scan\";\n      unsigned long currentTime = millis();\n      if (lastModeMessage != \"scan\" || (currentTime - lastModeTime) &gt; MODE_MESSAGE_COOLDOWN) {\n        Serial.println(\"\ud83d\udcf8 Scan mode active\");\n        lastModeMessage = \"scan\";\n        lastModeTime = currentTime;\n      }\n\n      // ===== MOTOR CONTROL: SCAN MODE =====\n      // TODO: Add scan mode motor actions here\n      // Examples: position camera, start conveyor for scanning, etc.\n\n    } else if (input == \"sort\") {\n      currentMode = \"sort\";\n      unsigned long currentTime = millis();\n      if (itemsLoaded) {\n        if (lastModeMessage != \"sort\" || (currentTime - lastModeTime) &gt; MODE_MESSAGE_COOLDOWN) {\n          if (binarySortActive) {\n            Serial.println(\"\u2699\ufe0f Binary sort mode active\");\n          } else {\n            Serial.println(\"\u274c Binary sort not activated - use SET_TARGET first\");\n          }\n          lastModeMessage = \"sort\";\n          lastModeTime = currentTime;\n        }\n      } else {\n        Serial.println(\"\u274c Cannot sort - no objects loaded\");\n      }\n\n      // ===== MOTOR CONTROL: SORT MODE =====\n      // TODO: Add sort mode motor actions here  \n      // Examples: start conveyor belt, position sorting mechanisms, etc.\n\n    } else if (input == \"stop\") {\n      currentMode = \"\";\n      Serial.println(\"\u23f9\ufe0f Stopped\");\n      lastModeMessage = \"\"; // Reset so next mode change shows message\n      lastSortedItem = \"\"; // Reset sort cooldown\n\n      // ===== MOTOR CONTROL: STOP ALL =====\n      // TODO: Add emergency stop actions here\n      // Examples: stop all motors, return servos to safe positions, etc.\n\n    } else {\n      Serial.print(\"\u2753 Unknown command: \");\n      Serial.println(input);\n    }\n  }\n\n  // ===== MOTOR CONTROL: MAIN LOOP TASKS =====\n  // TODO: Add any continuous motor control tasks here\n  // Examples: sensor monitoring, position feedback, safety checks, etc.\n}\n</code></pre>"},{"location":"software_v2/#demonstration-video-to-come","title":"Demonstration (VIDEO TO COME)","text":"<p>Video will be placed here.</p>"}]}