{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"YOLO-Based Binary Object Sorting System","text":"<p>Welcome! This GitHub page will contain documentation regarding what this project is about as well as progress for where I am at and all developments that have occured. This will serve as a log of my progress.</p> <p>Check out my engineering portfolio to see other projects!</p>"},{"location":"#about-me","title":"About Me","text":"<p>My name is Sidh Gurnani, and I studied Mechanical Engineering at Purdue University, and graduated with my Bachelor's in May 2025. I have been working on this project since June 2024.</p>"},{"location":"#project-milestones-progress","title":"Project Milestones + Progress","text":"<p>Here is a look at where I am at now: </p> Refresh Programming Knowledge Understand Basics of Machine Learning Develop Basic Software 3D Model and Design Physical Product Integrate Software and Hardware Final Testing Reflection and Next Steps"},{"location":"WebUSB_Findings/","title":"WebUSB Findings","text":"<p>This page outlines the basics of WebUSB, and how I set it up and tested for basic functionality. It also outlines my conclusion, which was presented on the Architecture page.</p> <p>WebUSB is an API that allows certain compatible microcontrollers to be able to communicate to a web browser. This would open up the potential for users to be able to interact with the Arduino using an HTML file. </p> <p>This relates to the project, as it is possible to be able to have a videofeed and have the user see what is going on and allow for a bit of manual control.</p> <p>This guide has some demos as well as code that can be ran to ensure that WebUSB is working as expected. The following is an adapted version of the tutorials presented in this video. For more information about the code and details about WebUSB, watch the linked video. </p>"},{"location":"WebUSB_Findings/#outline-of-demos","title":"Outline of Demos","text":"<ol> <li>USB Recognition</li> <li>Microcontroller to Web Browser Communication</li> <li>Web Browser to Microcontroller Communication</li> </ol>"},{"location":"WebUSB_Findings/#usb-recognition","title":"USB Recognition","text":"<p>The goal of this demo is to create a basic website that will allow the user to plug in a USB device and obtain important details to the console. This demo does not require the use of the WebUSB library, and no code needs to be uploaded to the microcontroller. This means that ANY device, regardless of whether it supports WebUSB or not, can run this test successfully, as this relies on the browser picking up the fact that a USB was plugged in rather than communicating with it.</p> USB_recog.html<pre><code>&lt;a href=\"#\" id=\"click\"&gt;Connect to USB Device&lt;/a&gt;\n\n&lt;script&gt;\nclick.onclick = function() {\n    navigator.usb.requestDevice( {filters: [\n        {'vendorId': 0x2341}\n    ]})\n    .then(device =&gt; {\n        console.log(device)\n        console.log(\"Product Name: \" + device.productName.toString(16))\n        console.log(\"Product ID: \" + device.productId.toString(16))\n        console.log(\"Vendor ID: \"+ device.vendorId.toString(16))\n    })\n    .catch(error =&gt; {\n        console.log(error)\n    })\n}\n&lt;/script&gt;\n</code></pre> <p>Images below show output of html code and how it works when an Arduino Leonardo is connected:</p> <p></p> <p></p> <p>Note that no code is needed for the Arduino.</p>"},{"location":"WebUSB_Findings/#microcontroller-to-web-browser-communication","title":"Microcontroller to Web Browser Communication","text":"<p>The goal of this demo is to be able to send data from the microcontroller and the website. While this demo will work in this particular way, it sets up the backbone for establishing a 2 way communication between the microcontroller and the website.</p> <p>HTML Code:</p> Leo_to_Web.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;USB Communication Test&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;a href=\"#\" id=\"click\"&gt;Listen to Leo&lt;/a&gt;\n        &lt;button id=\"connect\"&gt;Connect&lt;/button&gt;\n\n        &lt;script src=\"serial.js\"&gt;&lt;/script&gt;\n\n        &lt;script&gt;\n            document.getElementById('click').onclick = function() {\n                navigator.usb.requestDevice({ filters: [{ 'vendorId': 0x2341 }] })\n                    .then(device =&gt; {\n                        console.log(device);\n                        console.log(\"Product Name: \" + device.productName);\n                        console.log(\"Product ID: \" + device.productId.toString(16));\n                        console.log(\"Vendor ID: \" + device.vendorId.toString(16));\n                        console.log(\"Device Found! Awaiting messages...\");\n                    })\n                    .catch(error =&gt; {\n                        console.log(error);\n                    });\n            };\n\n            var port;\n            var connectButton = document.getElementById('connect');\n            var textDecoder = new TextDecoder();\n            var textEncoder = new TextEncoder();\n\n            connectButton.addEventListener('click', function() {\n              if (port) {\n                    // If port is already connected, disconnect it\n                    connectButton.textContent = 'Connect';\n                    port.disconnect();\n                    port = null;\n                    console.log('Device is disconnected.');\n                } else {\n                    // If there is no port, then connect to a new port\n                    serial.requestPort().then(selectedPort =&gt; {\n                        port = selectedPort;\n                        port.connect().then(() =&gt; {\n                            console.log('Device is connected to Product ID: ' + port.device_.productId.toString(16) + ' and Vendor ID: ' + port.device_.vendorId.toString(16));\n\n                            connectButton.textContent = 'Disconnect';\n                            port.onReceive = data =&gt; {\n                                console.log(textDecoder.decode(data));\n                            };\n                            port.onReceiveError = error =&gt; {\n                                console.log('Receive error: ' + error);\n                            };\n                        }, error =&gt; {\n                            console.log('Connection error: ' + error);\n                        });\n                    }).catch(error =&gt; {\n                        console.log('Connection error: ' + error);\n                    });\n                }\n            });\n\n            serial.requestPort = function() {\n                const filters = [\n                    { 'vendorId': 0x2341 }\n                ];\n                return navigator.usb.requestDevice({ 'filters': filters }).then(\n                    device =&gt; new serial.Port(device)\n                );\n            };\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Arduino Code:</p> Leo2.ino<pre><code>#include &lt;WebUSB.h&gt;\n\n// Modified from example https://webusb.github.io/arduino/demos/console\nWebUSB WebUSBSerial(1, \"webusb.github.io/arduino/demos/console\");\nint c = 0;\n\nvoid setup() {\n  WebUSBSerial.begin(9600);\n  while (!WebUSBSerial) {}\n  delay(100);\n}\n\nvoid loop() {\n  c = c + 1;\n  if (WebUSBSerial){\n    WebUSBSerial.println(c);\n    WebUSBSerial.flush();    \n  } else {\n    c = 0;\n  }\n\n  delay(1000);\n}\n</code></pre> <p>Serial.js code:</p> serial.js<pre><code>var serial = {};\n\n(function() {\n  'use strict';\n\n  serial.getPorts = function() {\n    return navigator.usb.getDevices().then(devices =&gt; {\n      return devices.map(device =&gt; new serial.Port(device));\n    });\n  };\n\n  serial.requestPort = function() {\n    const filters = [\n      { 'vendorId': 0x2341, 'productId': 0x8036 }, // Arduino Leonardo\n      { 'vendorId': 0x2341, 'productId': 0x8037 }, // Arduino Micro\n      { 'vendorId': 0x2341, 'productId': 0x804d }, // Arduino/Genuino Zero\n      { 'vendorId': 0x2341, 'productId': 0x804e }, // Arduino/Genuino MKR1000\n      { 'vendorId': 0x2341, 'productId': 0x804f }, // Arduino MKRZERO\n      { 'vendorId': 0x2341, 'productId': 0x8050 }, // Arduino MKR FOX 1200\n      { 'vendorId': 0x2341, 'productId': 0x8052 }, // Arduino MKR GSM 1400\n      { 'vendorId': 0x2341, 'productId': 0x8053 }, // Arduino MKR WAN 1300\n      { 'vendorId': 0x2341, 'productId': 0x8054 }, // Arduino MKR WiFi 1010\n      { 'vendorId': 0x2341, 'productId': 0x8055 }, // Arduino MKR NB 1500\n      { 'vendorId': 0x2341, 'productId': 0x8056 }, // Arduino MKR Vidor 4000\n      { 'vendorId': 0x2341, 'productId': 0x8057 }, // Arduino NANO 33 IoT\n      { 'vendorId': 0x239A }, // Adafruit Boards!\n    ];\n    return navigator.usb.requestDevice({ 'filters': filters }).then(\n      device =&gt; new serial.Port(device)\n    );\n  }\n\n  serial.Port = function(device) {\n    this.device_ = device;\n    this.interfaceNumber_ = 2;  // original interface number of WebUSB Arduino demo\n    this.endpointIn_ = 5;       // original in endpoint ID of WebUSB Arduino demo\n    this.endpointOut_ = 4;      // original out endpoint ID of WebUSB Arduino demo\n  };\n\n  serial.Port.prototype.connect = function() {\n    let readLoop = () =&gt; {\n      this.device_.transferIn(this.endpointIn_, 64).then(result =&gt; {\n        this.onReceive(result.data);\n        readLoop();\n      }, error =&gt; {\n        this.onReceiveError(error);\n      });\n    };\n\n    return this.device_.open()\n        .then(() =&gt; {\n          if (this.device_.configuration === null) {\n            return this.device_.selectConfiguration(1);\n          }\n        })\n        .then(() =&gt; {\n          var configurationInterfaces = this.device_.configuration.interfaces;\n          configurationInterfaces.forEach(element =&gt; {\n            element.alternates.forEach(elementalt =&gt; {\n              if (elementalt.interfaceClass==0xff) {\n                this.interfaceNumber_ = element.interfaceNumber;\n                elementalt.endpoints.forEach(elementendpoint =&gt; {\n                  if (elementendpoint.direction == \"out\") {\n                    this.endpointOut_ = elementendpoint.endpointNumber;\n                  }\n                  if (elementendpoint.direction==\"in\") {\n                    this.endpointIn_ =elementendpoint.endpointNumber;\n                  }\n                })\n              }\n            })\n          })\n        })\n        .then(() =&gt; this.device_.claimInterface(this.interfaceNumber_))\n        .then(() =&gt; this.device_.selectAlternateInterface(this.interfaceNumber_, 0))\n        // The vendor-specific interface provided by a device using this\n        // Arduino library is a copy of the normal Arduino USB CDC-ACM\n        // interface implementation and so reuses some requests defined by\n        // that specification. This request sets the DTR (data terminal\n        // ready) signal high to indicate to the device that the host is\n        // ready to send and receive data.\n        .then(() =&gt; this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x01,\n            'index': this.interfaceNumber_}))\n        .then(() =&gt; {\n          readLoop();\n        });\n  };\n\n  serial.Port.prototype.disconnect = function() {\n    // This request sets the DTR (data terminal ready) signal low to\n    // indicate to the device that the host has disconnected.\n    return this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x00,\n            'index': this.interfaceNumber_})\n        .then(() =&gt; this.device_.close());\n  };\n\n  serial.Port.prototype.send = function(data) {\n    return this.device_.transferOut(this.endpointOut_, data);\n  };\n})();\n</code></pre> <p>Images below show output and how it works when an Arduino Leonardo is connected:</p> <p></p> <p></p>"},{"location":"WebUSB_Findings/#web-browser-to-microcontroller-communication-blinky","title":"Web Browser to Microcontroller Communication \u2192 Blinky","text":"<p>The goal of this demo is to be able to control a microcontroller by having the user interface with a website. For the project, it would open up many possibilities for human interaction as the sorter is working through sorting. As of today, the only thing that makes sense would be to have a manual override in case something goes wrong, and maybe a stop and start function. An HTML would also be able to display possible metrics that are coming in from the microcontroller. This would include how many items were sorted, a running count of each type of item sorted, etc. Metrics are something that I would consider desirable and not required. The biggest use case of the website would be to train the ML model that would be used to then sort. This would be something very similar to what is implemented on Teachable Machine by Google. </p> <p>This demo uses an Arduino Leonardo and an HTML file to turn on and off the builtin LED. </p> <p>HTML Code:</p> Leo_to_Web_BLINKY.html<pre><code>&lt;a href=\"#\" id=\"connect\"&gt;Connect&lt;/a&gt;\n\n&lt;p&gt;\n    &lt;button id=\"on\"&gt;LED ON&lt;/button&gt;\n    &lt;button id=\"off\"&gt;LED OFF&lt;/button&gt;\n&lt;/p&gt;\n\n&lt;script src=\"serial.js\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\n    serial.requestPort = function() {\n        const filters = [\n            {'vendorId': 0x2341}\n        ];\n        return navigator.usb.requestDevice({'filters': filters}).then(\n            device =&gt; new serial.Port(device)\n        );\n    }\n\n    var port;\n    var connectButton = document.getElementById('connect');\n    var textDecoder = new TextDecoder();\n    var textEncoder = new TextEncoder();\n\n    document.querySelector('#on').addEventListener('click', function() {\n        if (port !== undefined) {\n            port.send(textEncoder.encode('H')).catch(error =&gt; {\n                console.log(\"Error: \" + error)\n            })\n            console.log(\"HTML: Turning on the LED!\")\n        }\n    })\n\n    document.querySelector('#off').addEventListener('click', function() {\n        if (port !== undefined) {\n            port.send(textEncoder.encode('L')).catch(error =&gt; {\n                console.log(\"Error: \" + error)\n            })\n            console.log(\"HTML: Turning off the LED!\")\n        }\n    })\n\n\n    connectButton.addEventListener('click', function() {\n              if (port) {\n                    // If port is already connected, disconnect it\n                    connectButton.textContent = 'Connect';\n                    port.disconnect();\n                    port = null;\n                    console.log('Device is disconnected.');\n                } else {\n                    // If there is no port, then connect to a new port\n                    serial.requestPort().then(selectedPort =&gt; {\n                        port = selectedPort;\n                        port.connect().then(() =&gt; {\n                            console.log('Device is connected to Product ID: ' + port.device_.productId.toString(16) + ' and Vendor ID: ' + port.device_.vendorId.toString(16));\n\n                            connectButton.textContent = 'Disconnect';\n                            port.onReceive = data =&gt; {\n                                console.log(textDecoder.decode(data));\n                            };\n                            port.onReceiveError = error =&gt; {\n                                console.log('Receive error: ' + error);\n                            };\n                        }, error =&gt; {\n                            console.log('Connection error: ' + error);\n                        });\n                    }).catch(error =&gt; {\n                        console.log('Connection error: ' + error);\n                    });\n                }\n            });\n&lt;/script&gt;\n</code></pre> <p>Arduino Code:</p> Blinky.ino<pre><code>#include &lt;WebUSB.h&gt;\nWebUSB WebUSBSerial(1, \"webusb.github.io/arduino/demos/console\");\n\nconst int ledPin = 13;\n\nvoid setup() {\n  WebUSBSerial.begin(9600);\n  while (!WebUSBSerial) {}\n  delay(100);\n\n  SerialUSB.begin(9600);\n  delay(100);\n\n  WebUSBSerial.write(\"Starting blinky!\");\n  WebUSBSerial.flush();\n  SerialUSB.println(\"Starting...\");\n\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  if (WebUSBSerial &amp;&amp; WebUSBSerial.available()) {\n    char byte = WebUSBSerial.read();  // Read the incoming byte as a character\n    WebUSBSerial.write(byte);  // Echo the received byte\n\n    if (byte == 'H') {  // Compare the byte with the character 'H'\n      SerialUSB.println(\"Received H!\");\n      WebUSBSerial.write(\"\\nTurning on LED\");\n      digitalWrite(ledPin, HIGH);  // Turn the LED on\n    } else if (byte == 'L') {  // Compare the byte with the character 'L'\n      SerialUSB.println(\"Received L!\");\n      WebUSBSerial.write(\"\\nTurning off LED\");\n      digitalWrite(ledPin, LOW);  // Turn the LED off\n    }\n\n    WebUSBSerial.flush();\n  }\n}\n</code></pre> <p>Serial.js code (same as before, provided for reference):</p> serial.js<pre><code>var serial = {};\n\n(function() {\n  'use strict';\n\n  serial.getPorts = function() {\n    return navigator.usb.getDevices().then(devices =&gt; {\n      return devices.map(device =&gt; new serial.Port(device));\n    });\n  };\n\n  serial.requestPort = function() {\n    const filters = [\n      { 'vendorId': 0x2341, 'productId': 0x8036 }, // Arduino Leonardo\n      { 'vendorId': 0x2341, 'productId': 0x8037 }, // Arduino Micro\n      { 'vendorId': 0x2341, 'productId': 0x804d }, // Arduino/Genuino Zero\n      { 'vendorId': 0x2341, 'productId': 0x804e }, // Arduino/Genuino MKR1000\n      { 'vendorId': 0x2341, 'productId': 0x804f }, // Arduino MKRZERO\n      { 'vendorId': 0x2341, 'productId': 0x8050 }, // Arduino MKR FOX 1200\n      { 'vendorId': 0x2341, 'productId': 0x8052 }, // Arduino MKR GSM 1400\n      { 'vendorId': 0x2341, 'productId': 0x8053 }, // Arduino MKR WAN 1300\n      { 'vendorId': 0x2341, 'productId': 0x8054 }, // Arduino MKR WiFi 1010\n      { 'vendorId': 0x2341, 'productId': 0x8055 }, // Arduino MKR NB 1500\n      { 'vendorId': 0x2341, 'productId': 0x8056 }, // Arduino MKR Vidor 4000\n      { 'vendorId': 0x2341, 'productId': 0x8057 }, // Arduino NANO 33 IoT\n      { 'vendorId': 0x239A }, // Adafruit Boards!\n    ];\n    return navigator.usb.requestDevice({ 'filters': filters }).then(\n      device =&gt; new serial.Port(device)\n    );\n  }\n\n  serial.Port = function(device) {\n    this.device_ = device;\n    this.interfaceNumber_ = 2;  // original interface number of WebUSB Arduino demo\n    this.endpointIn_ = 5;       // original in endpoint ID of WebUSB Arduino demo\n    this.endpointOut_ = 4;      // original out endpoint ID of WebUSB Arduino demo\n  };\n\n  serial.Port.prototype.connect = function() {\n    let readLoop = () =&gt; {\n      this.device_.transferIn(this.endpointIn_, 64).then(result =&gt; {\n        this.onReceive(result.data);\n        readLoop();\n      }, error =&gt; {\n        this.onReceiveError(error);\n      });\n    };\n\n    return this.device_.open()\n        .then(() =&gt; {\n          if (this.device_.configuration === null) {\n            return this.device_.selectConfiguration(1);\n          }\n        })\n        .then(() =&gt; {\n          var configurationInterfaces = this.device_.configuration.interfaces;\n          configurationInterfaces.forEach(element =&gt; {\n            element.alternates.forEach(elementalt =&gt; {\n              if (elementalt.interfaceClass==0xff) {\n                this.interfaceNumber_ = element.interfaceNumber;\n                elementalt.endpoints.forEach(elementendpoint =&gt; {\n                  if (elementendpoint.direction == \"out\") {\n                    this.endpointOut_ = elementendpoint.endpointNumber;\n                  }\n                  if (elementendpoint.direction==\"in\") {\n                    this.endpointIn_ =elementendpoint.endpointNumber;\n                  }\n                })\n              }\n            })\n          })\n        })\n        .then(() =&gt; this.device_.claimInterface(this.interfaceNumber_))\n        .then(() =&gt; this.device_.selectAlternateInterface(this.interfaceNumber_, 0))\n        // The vendor-specific interface provided by a device using this\n        // Arduino library is a copy of the normal Arduino USB CDC-ACM\n        // interface implementation and so reuses some requests defined by\n        // that specification. This request sets the DTR (data terminal\n        // ready) signal high to indicate to the device that the host is\n        // ready to send and receive data.\n        .then(() =&gt; this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x01,\n            'index': this.interfaceNumber_}))\n        .then(() =&gt; {\n          readLoop();\n        });\n  };\n\n  serial.Port.prototype.disconnect = function() {\n    // This request sets the DTR (data terminal ready) signal low to\n    // indicate to the device that the host has disconnected.\n    return this.device_.controlTransferOut({\n            'requestType': 'class',\n            'recipient': 'interface',\n            'request': 0x22,\n            'value': 0x00,\n            'index': this.interfaceNumber_})\n        .then(() =&gt; this.device_.close());\n  };\n\n  serial.Port.prototype.send = function(data) {\n    return this.device_.transferOut(this.endpointOut_, data);\n  };\n})();\n</code></pre> <p>Images below show output and how it works:</p> <p></p> <p></p>"},{"location":"WebUSB_Findings/#conclusion","title":"Conclusion","text":"<p>WebUSB is not ideal (from a simplicity point of view) due to the communication protocol that needs to be put in place. With any webpage, a client and server is needed. However, this communication would have to be extended to the Arduino as well. With a large amount of communication happening between the user, client, server, and Arduino, there is bound to be a loss of data somewhere due to data being sent and recieved from multiple sources, essentially overloading the system. While the ideal scenario would be to run something like this, my prototype will not be using a web-based system to reduce the complexity of communicating information.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#software-considerations","title":"Software Considerations","text":"<p>Early in the project timeline, the focus for any architectural decisions was heavily biased towards the software, as there are many possibilities for the software, and significantly fewer physical prototype solutions. </p>"},{"location":"architecture/#early-software-decisions","title":"Early Software Decisions","text":"<p>Given that the project solution requires a cyberphysical system, it is best to work with some kind of microcontroller. In addition, since laptops can vary with processing power, age, graphics performance, etc, it is best to utilize a solution that is lighter on a laptop. The goal here is to have as many devices as possible be able to run the software. </p> <p>This is where the first major pathway to a solution arrives: using WebUSB. WebUSB is an API that allows certain compatible microcontrollers to be able to communicate to a web browser. This would open up the potential for users to be able to interact with the Arduino using an HTML file. Keeping this solution on a web browser would be able to allow the system to run much lighter.</p> <p>Such a solution can be seen with Google's Tiny Sorter, which is primarily used as a teaching tool to help people learn about computer vision and sorting. One of the main drawbacks about this solution is that it doesn't accomodate for a variety of object types, and would be difficult to sort larger and heavier objects. It also does not allow a user to input a pretrained model, and instead relies on the end user to train the system. If done improperly, or in bad lighting, then the model produced is not as accurate.</p> <p>This led me down a rabbit hole of using WebUSB and getting my hands on an Arduino Leonardo, which is a WebUSB-compatible Arduino. My findings about WebUSB are laid out in more detail here.</p> <p>Long story short, WebUSB is not ideal (from a simplicity point of view) due to the communication protocol that needs to be put in place. With any webpage, a client and server is needed. However, this communication would have to be extended to the Arduino as well. With a large amount of communication happening between the user, client, server, and Arduino, there is bound to be a loss of data somewhere due to data being sent and recieved from multiple sources, essentially overloading the system. While the ideal scenario would be to run something like this, my prototype will not be using a web-based system to reduce the complexity of communicating information. </p>"},{"location":"architecture/#final-software-decisions","title":"Final Software Decisions","text":"<p>Based on the information outlined above, I have chosen to run the program locally. A graphical user interface (GUI) will be built via Python, which will also handle communication to and from the Arduino via a serial communication port. </p> <p>The GUI will allow the user to dictate what gets done and when as well as monitor the whole system and provide that information to the user. A GUI can be constructed in many ways, however, I have chosen to use tkinter for Python. </p> <p>Communication to and from the Arduino via a serial communication port is a good option as it allows data to be sent to and from using one channel, whereas using WebUSB would mean data has to transfer from client to server to Arduino. </p> <p>More technical details can be seen on the development pages, where the software versions are outlined as I iterate through them towards a working solution. </p>"},{"location":"architecture/#prototype-considerations-work-in-progress","title":"Prototype Considerations (WORK IN PROGRESS)","text":""},{"location":"architecture/#early-prototype-decisions","title":"Early Prototype Decisions","text":"<p>Early on, the choice had to be made to decide whether to design a prototype that works well with one kind of object or womething that won't work as well but can support a varierty of objects. </p> <p>Initially, I thought about going with the former. Coins are something that a lot of people have at their homes, including myself, and I thought testing using that would be great. I had initially wanted to design a system that works really well with coins, but coins only. However, it is more ideal to use a system that can support a variety of objects, even at reduced ability and capacity, as it allows for a proper proof of concept to be established with a relatively universal solution.</p> <p>There are more things that need to be figured out before designing any prototype:</p> <ul> <li>How are objects fed into system?</li> <li>What happens if the user cannot feed objects one-by-one? How does the system handle this?</li> <li>How can the system detect the objects in a webcam? Should a box be built around the webcam and an LED to illuminate it or is there another solution?</li> <li>What mode of movement should objects use when sending an object to the webcam and from the webcam to the bin?</li> <li>etc...</li> </ul>"},{"location":"architecture/#final-prototype-decisions","title":"Final Prototype Decisions","text":"<p>Here are some answers to some of the questions I posed above?</p> <ul> <li>How are objects fed into system? \u2192 They can be fed one by one or ideally, through some kind of feeder, either vibration based or centrifugal.</li> <li>What happens if the user cannot feed objects one-by-one? How does the system handle this? \u2192 Using something like a feeder can allow objects to be fed more uniformly, regardless of how the user would load the objects.</li> <li>How can the system detect the objects in a webcam? Should a box be built around the webcam and an LED to illuminate it or is there another solution? \u2192 ....</li> <li>What mode of movement should objects use when sending an object to the webcam and from the webcam to the bin? \u2192 ....</li> </ul>"},{"location":"intro/","title":"Introduction and Motivation","text":"<p>When a bullet is fired at a crime scene it leaves behind a casing and the bullet itself. The bullet size varies depending on the gun that is being used, but each bullet contains a unique identification that can be traced back to a specific gun that it was fired with. There is currently a relatively outdated process in place, whereby an examiner will have to manually measure and identify markings. While more advanced versions of this technique can be used (standards determined by NIST), it still heavily relies on an examiner going through. While human input can be deemed necessary, it is an inefficient process that can be streamlined if the bullets were able to be somehow pre-sorted. This would save time and make the process more efficient. </p> <p>Designing a new device would also require engineers to justify the need for such a product, and also delve into how it can be used in other applications. There are similar existing problems in other applications. An example of such an application would be coin sorting. If there were 1000 assorted coins of differing currencies, it would be possible to sort by hand albeit through a lengthy procedure. Another example is in an agricultural setting, where one would have to maybe sort through 2-3 different types of beans efficiently. Other examples include but are not limited to: various assorted electrical components (resistors, op-amps, capacitors, etc), assorted LEGOs, and assorted perler beads. </p> <p>An ideal device would be able to use an image of the product, identify what it is, and sort it based on the context of what would be coming into the device. This type of device can be designed using machine learning (ML), which is trained using images of a certain category. Note that this is a simplified version of the pipeline, and a more detailed pipeline will be ironed out in later phases of the design and prototyping process. There are various pros and cons to using ML in such an application, with the biggest pro being the ability to make an inefficient process more efficient and the biggest con being that the ability of the device functioning properly depends entirely on how well the ML implementation is done. </p> <p>To my knowledge, there is not such a device in the market, but there are aspects of the solution that are working in the market, and serve as a proof of concept. The first of these are a series of apps that are able to use the image of a coin to be able to give relevant information to the user. An example of such an app is \u201cCoinSnap\u201d, which allows users to scan coins and be provided with information and facts about that specific coin. This idea can be extended to similar apps on a smartphone for different purposes, such as identifying stars in the night sky or even forms of wildlife. </p> <p>A second working proof of concept serves as a working example of such a device. A company called Bulher has created a sorting device that can sort things such as agricultural seeds, coffee beans, etc in their \u201cSORTEX\u201d lineup. The device uses an optical sensor to be able to sort out a sample given the respective categories. </p> <p>But what if there was a solution that was more modular, something that could plug into a laptop and leverage its webcam to be able to physically sort through objects, not just identify them?</p> <p>References:</p> <p>Market Research:</p> <ul> <li> <p>Want to \u201cchange\u201d your fortune? Coin apps might help \u2192 Apps that take image of coins and are able to figure out its value</p> </li> <li> <p>GitHub - thim0o/CoinDetector \u2192 An image based coin counter using Python and Tensorflow Coin Detector on GitHub</p> </li> <li> <p>Optical Sorting Machines \u2192 Working Concept within Agriculture</p> </li> </ul> <p>Publications:</p> <ul> <li>Cell.com |  Intelligent Image-Activated Cell Sorting</li> <li>Nanocellect | Image-guided cell sorting technical overview</li> </ul>"},{"location":"milestones/","title":"Milestones","text":"<p>This page will contain a bit of information about each milestone as shown on the main page, including some of the goals of each, and if applicable, anything I have done to ensure that the milestone will be marked as \"complete\". For example, for testing, this page will contain information about any initially planned test runs, but will not cover the results. For more details descriptions of the architecture, design, testing, etc, view those respective pages in the navigation. </p>"},{"location":"milestones/#1-refresh-programming-knowledge","title":"1. Refresh Programming Knowledge","text":"<p>Based on my personal experiences, this phase of the project was more of a refresher for me. However, someone with less background with coding, in my opinion, should go through some coding lessons online and/or take a class. </p> <p>Prior to starting this project, I had used the following:</p> <ul> <li>Java</li> <li>MATLAB</li> <li>Python</li> <li>Arduino IDE</li> </ul> <p>Java was the first programming language I had learned, and I had done so in a more formal way by taking a course during my second semester of my undergrad. This class taught me the basics of Object Oriented Programming, and I was tasked with a variety of assignments with each one getting more complicated. I had learned the basics of everything from writing my first program to loops to client and server code. In addition, I had to work through a project at the end of the semester, where I worked with a team to code a basic learning interface similar to Canvas and Brightspace. </p> <p>I next learned MATLAB, which I used to complete the bulk of my engineering assignments during the first year engineering (FYE) curriculum that Purdue has in place. </p> <p>From there, I learned Python, also by taking a class at Purdue (EBEC 101). Here, I used Python in a traditional sense, by completing relatively simple assignments that taught me the basics of coding, but instead entirely in Python. </p> <p>After that, I learned how to program Arduinos using the Arduino IDE, albeit in a more nontraditional sense where I was introduced to everything in a more practical sense, and have since fine tuned my abilities through project-based learning. </p> <p>That being said, I had a decent background when it came to coding, so a few lessons in Python from YouTube were enough to get me going again and ready to learn more.</p> <p>For someone looking to replicate this, I would strongly suggest learning Python, as that is the programming language that is used throughout this project, as well as learning the basics behind working with Arduinos and familiarity with the IDE. I will also be using PlatformIO to run my project entirely in VSCode instead of using two different IDEs.</p>"},{"location":"milestones/#2-understand-basics-of-machine-learning","title":"2. Understand Basics of Machine Learning","text":"<p>Prior to starting this project, I had zero experience with Machine Learning. This is what I did to familiarize myself with the basics of ML. I ended up taking free online classes to refresh my Python knowledge and expand that understanding into machine learning. Links to the classes are below, with certificates on my LinkedIn page.</p> <ul> <li>Machine Learning with Python course | Cognitive Class</li> <li>Data Visualization with Python course | Cognitive Class</li> <li>Python for Data Science course | Cognitive Class</li> <li>Predictions: Regression for Car Mileage and Diamond Price</li> <li>Customer Clustering with KMeans to Boost Business Strategy</li> <li>Precise Predictions: Classification for Flower and Tumors</li> </ul> <p>While this is not by any means a guide to learning machine learning, the emphasis for this project was to familiarize myself with it and get better at implementing it as I progress through this project. </p>"},{"location":"milestones/#3-develop-basic-software","title":"3. Develop Basic Software","text":"<p>Developing basic software entails having code up and running for the software side of this project, which entails mainly getting YOLO working as well as setting up the interface and all basic functions that need to be in place for this to be successful. At the minimum, here is what is expected:</p> <ul> <li>Be intuitive to use, and look somewhat polished</li> <li>Allow user to perform basic functions</li> <li>Allow user control over the process</li> <li>At the minimum, recognize when an Arduino is connected via USB to laptop</li> <li>Leverage webcam to detect objects</li> <li>Have some error handling in place and prevent user from going too far out of order</li> </ul>"},{"location":"milestones/#4-3d-model-and-design-physical-product","title":"4. 3D Model and Design Physical Product","text":"<p>The goal here is to design a minimum viable prototype, where the parts and system is able to work adequately well and a well established proof of concept is present. At the minimum, here is what is expected:</p> <ul> <li>Be simple to use for the end user</li> <li>Allow user to perform basic functions, notably loading and sorting objects under supervision with minimal human intervention</li> <li>Allow user to load a small to medium number of items for sorting, mainly for testing purposes</li> <li>Objects should get sorted into 2 bins, where one is the target and the other is not the target, hence the \"binary\" aspect of the sorter</li> <li>Keep costs as low as possible, with the aim to be reproducible</li> </ul>"},{"location":"milestones/#5-integrate-software-and-hardware","title":"5. Integrate Software and Hardware","text":"<p>Once basic software and working prototype are set up, work needs to be done to integrate the software and prototype made earlier. Here, the different modes will be properly established:</p> <ul> <li>Object Detection Mode: Here, objects will pass through the mechanical system in place and not do any kind of sorting. The goal is to detect a list of unique objects so that the number of passes the system requires can be established.</li> <li>Object Sorting Mode: Here, objects will be sorted through the system, with motors/actuators being used to facilitate the sorting process.</li> </ul> <p>At this point, small scale testing will be carried out. The aim here is to get around 10-20 objects with at least 3 unique classes of objects properly sorted. </p>"},{"location":"milestones/#6-final-testing","title":"6. Final Testing","text":"<p>At this point, the system is well established, and the testing can be slightly scaled up. In addition, different models will be tested to ensure that the system is more \"plug and play\", where the end user will be able to train or load in a pytorch model to be used with YOLO.</p>"},{"location":"milestones/#7-reflection-and-next-steps","title":"7. Reflection and Next Steps","text":"<p>Reflections will be made here to discuss flaws of working prototype as well as a path forward should the project timeline be extended.</p>"},{"location":"progress/","title":"Project Progress","text":"Refresh Programming Knowledge Understand Basics of Machine Learning Develop Basic Software 3D Model and Design Physical Product Integrate Software and Hardware Final Testing Reflection and Next Steps"}]}